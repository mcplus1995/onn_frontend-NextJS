/**
 * Generated by @openapi-codegen
 *
 * @version 10.9.1
 */
import * as reactQuery from "@tanstack/react-query";
import { useBackendContext, BackendContext } from "./backendContext";
import type * as Fetcher from "./backendFetcher";
import { backendFetch } from "./backendFetcher";
import type * as Schemas from "./backendSchemas";
import type * as Responses from "./backendResponses";

export type GetAssetPathParams = {
  /**
   * The id of the file.
   */
  id: string;
};

export type GetAssetQueryParams = {
  /**
   * The key of the asset size configured in settings.
   */
  key?: string;
  /**
   * A JSON array of image transformations
   */
  transforms?: string;
  /**
   * Download the asset to your computer
   */
  download?: boolean;
};

export type GetAssetError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Responses.NotFoundError;
}>;

export type GetAssetVariables = {
  pathParams: GetAssetPathParams;
  queryParams?: GetAssetQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Image typed files can be dynamically resized and transformed to fit any need.
 */
export const fetchGetAsset = (
  variables: GetAssetVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    undefined,
    GetAssetError,
    undefined,
    {},
    GetAssetQueryParams,
    GetAssetPathParams
  >({ url: "/assets/{id}", method: "get", ...variables, signal });

/**
 * Image typed files can be dynamically resized and transformed to fit any need.
 */
export const useGetAsset = <TData = undefined>(
  variables: GetAssetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetAssetError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<undefined, GetAssetError, TData>({
    queryKey: queryKeyFn({
      path: "/assets/{id}",
      operationId: "getAsset",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetAsset({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type LoginError = Fetcher.ErrorWrapper<undefined>;

export type LoginResponse = {
  data?: {
    /**
     * @example eyJhbGciOiJI...
     */
    access_token?: string;
    /**
     * @example 900
     */
    expires?: number;
    /**
     * @example yuOJkjdPXMd...
     */
    refresh_token?: string;
  };
};

export type LoginRequestBody = {
  /**
   * Email address of the user you're retrieving the access token for.
   *
   * @example admin@example.com
   */
  email: string;
  /**
   * Password of the user.
   *
   * @format password
   * @example password
   */
  password: string;
  /**
   * Choose between retrieving the token as a string, or setting it as a cookie.
   *
   * @default json
   */
  mode?: "json" | "cookie";
  /**
   * If 2FA is enabled, you need to pass the one time password.
   */
  otp?: string;
};

export type LoginVariables = {
  body: LoginRequestBody;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a Temporary Access Token
 */
export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) =>
  backendFetch<LoginResponse, LoginError, LoginRequestBody, {}, {}, {}>({
    url: "/auth/login",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Retrieve a Temporary Access Token
 */
export const useLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<LoginResponse, LoginError, LoginVariables>,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<LoginResponse, LoginError, LoginVariables>({
    mutationFn: (variables: LoginVariables) =>
      fetchLogin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RefreshError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type RefreshResponse = {
  data?: {
    /**
     * @example eyJhbGciOiJI...
     */
    access_token?: string;
    /**
     * @example 900
     */
    expires?: number;
    /**
     * @example Gy-caJMpmGTA...
     */
    refresh_token?: string;
  };
};

export type RefreshRequestBody = {
  /**
   * JWT access token you want to refresh. This token can't be expired.
   *
   * @example eyJ0eXAiOiJKV...
   */
  refresh_token?: string;
};

export type RefreshVariables = {
  body: RefreshRequestBody;
} & BackendContext["fetcherOptions"];

/**
 * Refresh a Temporary Access Token.
 */
export const fetchRefresh = (
  variables: RefreshVariables,
  signal?: AbortSignal
) =>
  backendFetch<RefreshResponse, RefreshError, RefreshRequestBody, {}, {}, {}>({
    url: "/auth/refresh",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Refresh a Temporary Access Token.
 */
export const useRefresh = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      RefreshResponse,
      RefreshError,
      RefreshVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<
    RefreshResponse,
    RefreshError,
    RefreshVariables
  >({
    mutationFn: (variables: RefreshVariables) =>
      fetchRefresh({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LogoutError = Fetcher.ErrorWrapper<undefined>;

export type LogoutRequestBody = {
  /**
   * JWT access token you want to logout.
   *
   * @example eyJ0eXAiOiJKV...
   */
  refresh_token?: string;
};

export type LogoutVariables = {
  body: LogoutRequestBody;
} & BackendContext["fetcherOptions"];

/**
 * Log Out
 */
export const fetchLogout = (variables: LogoutVariables, signal?: AbortSignal) =>
  backendFetch<undefined, LogoutError, LogoutRequestBody, {}, {}, {}>({
    url: "/auth/logout",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Log Out
 */
export const useLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, LogoutError, LogoutVariables>,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<undefined, LogoutError, LogoutVariables>({
    mutationFn: (variables: LogoutVariables) =>
      fetchLogout({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PasswordRequestError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type PasswordRequestRequestBody = {
  /**
   * Email address of the user you're requesting a reset for.
   *
   * @example admin@example.com
   */
  email: string;
};

export type PasswordRequestVariables = {
  body: PasswordRequestRequestBody;
} & BackendContext["fetcherOptions"];

/**
 * Request a reset password email to be send.
 */
export const fetchPasswordRequest = (
  variables: PasswordRequestVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    undefined,
    PasswordRequestError,
    PasswordRequestRequestBody,
    {},
    {},
    {}
  >({ url: "/auth/password/request", method: "post", ...variables, signal });

/**
 * Request a reset password email to be send.
 */
export const usePasswordRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PasswordRequestError,
      PasswordRequestVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<
    undefined,
    PasswordRequestError,
    PasswordRequestVariables
  >({
    mutationFn: (variables: PasswordRequestVariables) =>
      fetchPasswordRequest({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type PasswordResetError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type PasswordResetRequestBody = {
  /**
   * One-time use JWT token that is used to verify the user.
   *
   * @example eyJ0eXAiOiJKV1Qi...
   */
  token: string;
  /**
   * New password for the user.
   *
   * @example password
   * @format password
   */
  password: string;
};

export type PasswordResetVariables = {
  body: PasswordResetRequestBody;
} & BackendContext["fetcherOptions"];

/**
 * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
 */
export const fetchPasswordReset = (
  variables: PasswordResetVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    undefined,
    PasswordResetError,
    PasswordResetRequestBody,
    {},
    {},
    {}
  >({ url: "/auth/password/reset", method: "post", ...variables, signal });

/**
 * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
 */
export const usePasswordReset = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PasswordResetError,
      PasswordResetVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<
    undefined,
    PasswordResetError,
    PasswordResetVariables
  >({
    mutationFn: (variables: PasswordResetVariables) =>
      fetchPasswordReset({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type OauthError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type OauthResponse = {
  public?: boolean;
  /**
   * @example github
   * @example facebook
   */
  data?: string[];
};

export type OauthVariables = BackendContext["fetcherOptions"];

/**
 * List configured OAuth providers.
 */
export const fetchOauth = (variables: OauthVariables, signal?: AbortSignal) =>
  backendFetch<OauthResponse, OauthError, undefined, {}, {}, {}>({
    url: "/auth/oauth",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List configured OAuth providers.
 */
export const useOauth = <TData = OauthResponse>(
  variables: OauthVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<OauthResponse, OauthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<OauthResponse, OauthError, TData>({
    queryKey: queryKeyFn({
      path: "/auth/oauth",
      operationId: "oauth",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchOauth({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type OauthProviderPathParams = {
  /**
   * Key of the activated OAuth provider.
   */
  provider: string;
};

export type OauthProviderQueryParams = {
  /**
   * Where to redirect on successful login.<br/>If set the authentication details are set inside cookies otherwise a JSON is returned.
   */
  redirect?: string;
};

export type OauthProviderError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type OauthProviderResponse = {
  public?: boolean;
  data?: {
    token?: string;
  };
};

export type OauthProviderVariables = {
  pathParams: OauthProviderPathParams;
  queryParams?: OauthProviderQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Start OAuth flow using the specified provider
 */
export const fetchOauthProvider = (
  variables: OauthProviderVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    OauthProviderResponse,
    OauthProviderError,
    undefined,
    {},
    OauthProviderQueryParams,
    OauthProviderPathParams
  >({ url: "/auth/oauth/{provider}", method: "get", ...variables, signal });

/**
 * Start OAuth flow using the specified provider
 */
export const useOauthProvider = <TData = OauthProviderResponse>(
  variables: OauthProviderVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      OauthProviderResponse,
      OauthProviderError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<OauthProviderResponse, OauthProviderError, TData>({
    queryKey: queryKeyFn({
      path: "/auth/oauth/{provider}",
      operationId: "oauthProvider",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchOauthProvider({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ServerInfoQueryParams = {
  /**
   * The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in `/config/__api.json` on your server.
   */
  super_admin_token: number;
};

export type ServerInfoError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ServerInfoResponse = {
  data?: Record<string, any>;
};

export type ServerInfoVariables = {
  queryParams: ServerInfoQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Perform a system status check and return the options.
 */
export const fetchServerInfo = (
  variables: ServerInfoVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ServerInfoResponse,
    ServerInfoError,
    undefined,
    {},
    ServerInfoQueryParams,
    {}
  >({ url: "/server/info", method: "get", ...variables, signal });

/**
 * Perform a system status check and return the options.
 */
export const useServerInfo = <TData = ServerInfoResponse>(
  variables: ServerInfoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ServerInfoResponse, ServerInfoError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<ServerInfoResponse, ServerInfoError, TData>({
    queryKey: queryKeyFn({
      path: "/server/info",
      operationId: "serverInfo",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchServerInfo({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type PingError = Fetcher.ErrorWrapper<undefined>;

export type PingVariables = BackendContext["fetcherOptions"];

/**
 * Ping, pong. Ping.. pong.
 */
export const fetchPing = (variables: PingVariables, signal?: AbortSignal) =>
  backendFetch<undefined, PingError, undefined, {}, {}, {}>({
    url: "/server/ping",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Ping, pong. Ping.. pong.
 */
export const usePing = <TData = undefined>(
  variables: PingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, PingError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<undefined, PingError, TData>({
    queryKey: queryKeyFn({
      path: "/server/ping",
      operationId: "ping",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchPing({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsEscalationPathwaysQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsEscalationPathwaysError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsEscalationPathwaysResponse = {
  data?: Schemas.ItemsEscalationPathways[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsEscalationPathwaysVariables = {
  queryParams?: ReadItemsEscalationPathwaysQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the escalation_pathways items.
 */
export const fetchReadItemsEscalationPathways = (
  variables: ReadItemsEscalationPathwaysVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsEscalationPathwaysResponse,
    ReadItemsEscalationPathwaysError,
    undefined,
    {},
    ReadItemsEscalationPathwaysQueryParams,
    {}
  >({ url: "/items/escalation_pathways", method: "get", ...variables, signal });

/**
 * List the escalation_pathways items.
 */
export const useReadItemsEscalationPathways = <
  TData = ReadItemsEscalationPathwaysResponse
>(
  variables: ReadItemsEscalationPathwaysVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsEscalationPathwaysResponse,
      ReadItemsEscalationPathwaysError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsEscalationPathwaysResponse,
    ReadItemsEscalationPathwaysError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/escalation_pathways",
      operationId: "readItemsEscalationPathways",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsEscalationPathways(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsEscalationPathwaysPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsEscalationPathwaysQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsEscalationPathwaysError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsEscalationPathwaysResponse = {
  data?: Schemas.ItemsEscalationPathways;
};

export type ReadSingleItemsEscalationPathwaysVariables = {
  pathParams: ReadSingleItemsEscalationPathwaysPathParams;
  queryParams?: ReadSingleItemsEscalationPathwaysQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single escalation_pathways item by unique identifier.
 */
export const fetchReadSingleItemsEscalationPathways = (
  variables: ReadSingleItemsEscalationPathwaysVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsEscalationPathwaysResponse,
    ReadSingleItemsEscalationPathwaysError,
    undefined,
    {},
    ReadSingleItemsEscalationPathwaysQueryParams,
    ReadSingleItemsEscalationPathwaysPathParams
  >({
    url: "/items/escalation_pathways/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single escalation_pathways item by unique identifier.
 */
export const useReadSingleItemsEscalationPathways = <
  TData = ReadSingleItemsEscalationPathwaysResponse
>(
  variables: ReadSingleItemsEscalationPathwaysVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsEscalationPathwaysResponse,
      ReadSingleItemsEscalationPathwaysError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsEscalationPathwaysResponse,
    ReadSingleItemsEscalationPathwaysError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/escalation_pathways/{id}",
      operationId: "readSingleItemsEscalationPathways",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsEscalationPathways(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsEscalationPathwayStatusesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsEscalationPathwayStatusesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsEscalationPathwayStatusesResponse = {
  data?: Schemas.ItemsEscalationPathwayStatuses[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsEscalationPathwayStatusesVariables = {
  queryParams?: ReadItemsEscalationPathwayStatusesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the escalation_pathway_statuses items.
 */
export const fetchReadItemsEscalationPathwayStatuses = (
  variables: ReadItemsEscalationPathwayStatusesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsEscalationPathwayStatusesResponse,
    ReadItemsEscalationPathwayStatusesError,
    undefined,
    {},
    ReadItemsEscalationPathwayStatusesQueryParams,
    {}
  >({
    url: "/items/escalation_pathway_statuses",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the escalation_pathway_statuses items.
 */
export const useReadItemsEscalationPathwayStatuses = <
  TData = ReadItemsEscalationPathwayStatusesResponse
>(
  variables: ReadItemsEscalationPathwayStatusesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsEscalationPathwayStatusesResponse,
      ReadItemsEscalationPathwayStatusesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsEscalationPathwayStatusesResponse,
    ReadItemsEscalationPathwayStatusesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/escalation_pathway_statuses",
      operationId: "readItemsEscalationPathwayStatuses",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsEscalationPathwayStatuses(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsEscalationPathwayStatusesPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsEscalationPathwayStatusesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsEscalationPathwayStatusesError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Responses.UnauthorizedError;
      }
    | {
        status: 404;
        payload: Responses.NotFoundError;
      }
  >;

export type ReadSingleItemsEscalationPathwayStatusesResponse = {
  data?: Schemas.ItemsEscalationPathwayStatuses;
};

export type ReadSingleItemsEscalationPathwayStatusesVariables = {
  pathParams: ReadSingleItemsEscalationPathwayStatusesPathParams;
  queryParams?: ReadSingleItemsEscalationPathwayStatusesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single escalation_pathway_statuses item by unique identifier.
 */
export const fetchReadSingleItemsEscalationPathwayStatuses = (
  variables: ReadSingleItemsEscalationPathwayStatusesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsEscalationPathwayStatusesResponse,
    ReadSingleItemsEscalationPathwayStatusesError,
    undefined,
    {},
    ReadSingleItemsEscalationPathwayStatusesQueryParams,
    ReadSingleItemsEscalationPathwayStatusesPathParams
  >({
    url: "/items/escalation_pathway_statuses/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single escalation_pathway_statuses item by unique identifier.
 */
export const useReadSingleItemsEscalationPathwayStatuses = <
  TData = ReadSingleItemsEscalationPathwayStatusesResponse
>(
  variables: ReadSingleItemsEscalationPathwayStatusesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsEscalationPathwayStatusesResponse,
      ReadSingleItemsEscalationPathwayStatusesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsEscalationPathwayStatusesResponse,
    ReadSingleItemsEscalationPathwayStatusesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/escalation_pathway_statuses/{id}",
      operationId: "readSingleItemsEscalationPathwayStatuses",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsEscalationPathwayStatuses(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsEscalationRegionsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsEscalationRegionsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsEscalationRegionsResponse = {
  data?: Schemas.ItemsEscalationRegions[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsEscalationRegionsVariables = {
  queryParams?: ReadItemsEscalationRegionsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the escalation_regions items.
 */
export const fetchReadItemsEscalationRegions = (
  variables: ReadItemsEscalationRegionsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsEscalationRegionsResponse,
    ReadItemsEscalationRegionsError,
    undefined,
    {},
    ReadItemsEscalationRegionsQueryParams,
    {}
  >({ url: "/items/escalation_regions", method: "get", ...variables, signal });

/**
 * List the escalation_regions items.
 */
export const useReadItemsEscalationRegions = <
  TData = ReadItemsEscalationRegionsResponse
>(
  variables: ReadItemsEscalationRegionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsEscalationRegionsResponse,
      ReadItemsEscalationRegionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsEscalationRegionsResponse,
    ReadItemsEscalationRegionsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/escalation_regions",
      operationId: "readItemsEscalationRegions",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsEscalationRegions(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsEscalationRegionsPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsEscalationRegionsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsEscalationRegionsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsEscalationRegionsResponse = {
  data?: Schemas.ItemsEscalationRegions;
};

export type ReadSingleItemsEscalationRegionsVariables = {
  pathParams: ReadSingleItemsEscalationRegionsPathParams;
  queryParams?: ReadSingleItemsEscalationRegionsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single escalation_regions item by unique identifier.
 */
export const fetchReadSingleItemsEscalationRegions = (
  variables: ReadSingleItemsEscalationRegionsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsEscalationRegionsResponse,
    ReadSingleItemsEscalationRegionsError,
    undefined,
    {},
    ReadSingleItemsEscalationRegionsQueryParams,
    ReadSingleItemsEscalationRegionsPathParams
  >({
    url: "/items/escalation_regions/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single escalation_regions item by unique identifier.
 */
export const useReadSingleItemsEscalationRegions = <
  TData = ReadSingleItemsEscalationRegionsResponse
>(
  variables: ReadSingleItemsEscalationRegionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsEscalationRegionsResponse,
      ReadSingleItemsEscalationRegionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsEscalationRegionsResponse,
    ReadSingleItemsEscalationRegionsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/escalation_regions/{id}",
      operationId: "readSingleItemsEscalationRegions",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsEscalationRegions(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsGlobalQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsGlobalError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsGlobalResponse = {
  data?: Schemas.ItemsGlobal[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsGlobalVariables = {
  queryParams?: ReadItemsGlobalQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the global items.
 */
export const fetchReadItemsGlobal = (
  variables: ReadItemsGlobalVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsGlobalResponse,
    ReadItemsGlobalError,
    undefined,
    {},
    ReadItemsGlobalQueryParams,
    {}
  >({ url: "/items/global", method: "get", ...variables, signal });

/**
 * List the global items.
 */
export const useReadItemsGlobal = <TData = ReadItemsGlobalResponse>(
  variables: ReadItemsGlobalVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsGlobalResponse,
      ReadItemsGlobalError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsGlobalResponse,
    ReadItemsGlobalError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/global",
      operationId: "readItemsGlobal",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsGlobal({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsGlobalPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsGlobalQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsGlobalError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsGlobalResponse = {
  data?: Schemas.ItemsGlobal;
};

export type ReadSingleItemsGlobalVariables = {
  pathParams: ReadSingleItemsGlobalPathParams;
  queryParams?: ReadSingleItemsGlobalQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single global item by unique identifier.
 */
export const fetchReadSingleItemsGlobal = (
  variables: ReadSingleItemsGlobalVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsGlobalResponse,
    ReadSingleItemsGlobalError,
    undefined,
    {},
    ReadSingleItemsGlobalQueryParams,
    ReadSingleItemsGlobalPathParams
  >({ url: "/items/global/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single global item by unique identifier.
 */
export const useReadSingleItemsGlobal = <TData = ReadSingleItemsGlobalResponse>(
  variables: ReadSingleItemsGlobalVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsGlobalResponse,
      ReadSingleItemsGlobalError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsGlobalResponse,
    ReadSingleItemsGlobalError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/global/{id}",
      operationId: "readSingleItemsGlobal",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsGlobal({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsHomepageQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsHomepageError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsHomepageResponse = {
  data?: Schemas.ItemsHomepage[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsHomepageVariables = {
  queryParams?: ReadItemsHomepageQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the homepage items.
 */
export const fetchReadItemsHomepage = (
  variables: ReadItemsHomepageVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsHomepageResponse,
    ReadItemsHomepageError,
    undefined,
    {},
    ReadItemsHomepageQueryParams,
    {}
  >({ url: "/items/homepage", method: "get", ...variables, signal });

/**
 * List the homepage items.
 */
export const useReadItemsHomepage = <TData = ReadItemsHomepageResponse>(
  variables: ReadItemsHomepageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsHomepageResponse,
      ReadItemsHomepageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsHomepageResponse,
    ReadItemsHomepageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/homepage",
      operationId: "readItemsHomepage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsHomepage({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsHomepagePathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsHomepageQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsHomepageError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsHomepageResponse = {
  data?: Schemas.ItemsHomepage;
};

export type ReadSingleItemsHomepageVariables = {
  pathParams: ReadSingleItemsHomepagePathParams;
  queryParams?: ReadSingleItemsHomepageQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single homepage item by unique identifier.
 */
export const fetchReadSingleItemsHomepage = (
  variables: ReadSingleItemsHomepageVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsHomepageResponse,
    ReadSingleItemsHomepageError,
    undefined,
    {},
    ReadSingleItemsHomepageQueryParams,
    ReadSingleItemsHomepagePathParams
  >({ url: "/items/homepage/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single homepage item by unique identifier.
 */
export const useReadSingleItemsHomepage = <
  TData = ReadSingleItemsHomepageResponse
>(
  variables: ReadSingleItemsHomepageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsHomepageResponse,
      ReadSingleItemsHomepageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsHomepageResponse,
    ReadSingleItemsHomepageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/homepage/{id}",
      operationId: "readSingleItemsHomepage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsHomepage({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsNavigationsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsNavigationsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsNavigationsResponse = {
  data?: Schemas.ItemsNavigations[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsNavigationsVariables = {
  queryParams?: ReadItemsNavigationsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the navigations items.
 */
export const fetchReadItemsNavigations = (
  variables: ReadItemsNavigationsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsNavigationsResponse,
    ReadItemsNavigationsError,
    undefined,
    {},
    ReadItemsNavigationsQueryParams,
    {}
  >({ url: "/items/navigations", method: "get", ...variables, signal });

/**
 * List the navigations items.
 */
export const useReadItemsNavigations = <TData = ReadItemsNavigationsResponse>(
  variables: ReadItemsNavigationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsNavigationsResponse,
      ReadItemsNavigationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsNavigationsResponse,
    ReadItemsNavigationsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/navigations",
      operationId: "readItemsNavigations",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsNavigations({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsNavigationsPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsNavigationsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsNavigationsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsNavigationsResponse = {
  data?: Schemas.ItemsNavigations;
};

export type ReadSingleItemsNavigationsVariables = {
  pathParams: ReadSingleItemsNavigationsPathParams;
  queryParams?: ReadSingleItemsNavigationsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single navigations item by unique identifier.
 */
export const fetchReadSingleItemsNavigations = (
  variables: ReadSingleItemsNavigationsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsNavigationsResponse,
    ReadSingleItemsNavigationsError,
    undefined,
    {},
    ReadSingleItemsNavigationsQueryParams,
    ReadSingleItemsNavigationsPathParams
  >({ url: "/items/navigations/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single navigations item by unique identifier.
 */
export const useReadSingleItemsNavigations = <
  TData = ReadSingleItemsNavigationsResponse
>(
  variables: ReadSingleItemsNavigationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsNavigationsResponse,
      ReadSingleItemsNavigationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsNavigationsResponse,
    ReadSingleItemsNavigationsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/navigations/{id}",
      operationId: "readSingleItemsNavigations",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsNavigations(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsSanctionEntitiesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsSanctionEntitiesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsSanctionEntitiesResponse = {
  data?: Schemas.ItemsSanctionEntities[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsSanctionEntitiesVariables = {
  queryParams?: ReadItemsSanctionEntitiesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the sanction_entities items.
 */
export const fetchReadItemsSanctionEntities = (
  variables: ReadItemsSanctionEntitiesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsSanctionEntitiesResponse,
    ReadItemsSanctionEntitiesError,
    undefined,
    {},
    ReadItemsSanctionEntitiesQueryParams,
    {}
  >({ url: "/items/sanction_entities", method: "get", ...variables, signal });

/**
 * List the sanction_entities items.
 */
export const useReadItemsSanctionEntities = <
  TData = ReadItemsSanctionEntitiesResponse
>(
  variables: ReadItemsSanctionEntitiesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsSanctionEntitiesResponse,
      ReadItemsSanctionEntitiesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsSanctionEntitiesResponse,
    ReadItemsSanctionEntitiesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanction_entities",
      operationId: "readItemsSanctionEntities",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsSanctionEntities(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsSanctionEntitiesPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsSanctionEntitiesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsSanctionEntitiesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsSanctionEntitiesResponse = {
  data?: Schemas.ItemsSanctionEntities;
};

export type ReadSingleItemsSanctionEntitiesVariables = {
  pathParams: ReadSingleItemsSanctionEntitiesPathParams;
  queryParams?: ReadSingleItemsSanctionEntitiesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single sanction_entities item by unique identifier.
 */
export const fetchReadSingleItemsSanctionEntities = (
  variables: ReadSingleItemsSanctionEntitiesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsSanctionEntitiesResponse,
    ReadSingleItemsSanctionEntitiesError,
    undefined,
    {},
    ReadSingleItemsSanctionEntitiesQueryParams,
    ReadSingleItemsSanctionEntitiesPathParams
  >({
    url: "/items/sanction_entities/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single sanction_entities item by unique identifier.
 */
export const useReadSingleItemsSanctionEntities = <
  TData = ReadSingleItemsSanctionEntitiesResponse
>(
  variables: ReadSingleItemsSanctionEntitiesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsSanctionEntitiesResponse,
      ReadSingleItemsSanctionEntitiesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsSanctionEntitiesResponse,
    ReadSingleItemsSanctionEntitiesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanction_entities/{id}",
      operationId: "readSingleItemsSanctionEntities",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsSanctionEntities(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsSanctionSectorsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsSanctionSectorsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsSanctionSectorsResponse = {
  data?: Schemas.ItemsSanctionSectors[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsSanctionSectorsVariables = {
  queryParams?: ReadItemsSanctionSectorsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the sanction_sectors items.
 */
export const fetchReadItemsSanctionSectors = (
  variables: ReadItemsSanctionSectorsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsSanctionSectorsResponse,
    ReadItemsSanctionSectorsError,
    undefined,
    {},
    ReadItemsSanctionSectorsQueryParams,
    {}
  >({ url: "/items/sanction_sectors", method: "get", ...variables, signal });

/**
 * List the sanction_sectors items.
 */
export const useReadItemsSanctionSectors = <
  TData = ReadItemsSanctionSectorsResponse
>(
  variables: ReadItemsSanctionSectorsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsSanctionSectorsResponse,
      ReadItemsSanctionSectorsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsSanctionSectorsResponse,
    ReadItemsSanctionSectorsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanction_sectors",
      operationId: "readItemsSanctionSectors",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsSanctionSectors(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsSanctionSectorsPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsSanctionSectorsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsSanctionSectorsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsSanctionSectorsResponse = {
  data?: Schemas.ItemsSanctionSectors;
};

export type ReadSingleItemsSanctionSectorsVariables = {
  pathParams: ReadSingleItemsSanctionSectorsPathParams;
  queryParams?: ReadSingleItemsSanctionSectorsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single sanction_sectors item by unique identifier.
 */
export const fetchReadSingleItemsSanctionSectors = (
  variables: ReadSingleItemsSanctionSectorsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsSanctionSectorsResponse,
    ReadSingleItemsSanctionSectorsError,
    undefined,
    {},
    ReadSingleItemsSanctionSectorsQueryParams,
    ReadSingleItemsSanctionSectorsPathParams
  >({
    url: "/items/sanction_sectors/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single sanction_sectors item by unique identifier.
 */
export const useReadSingleItemsSanctionSectors = <
  TData = ReadSingleItemsSanctionSectorsResponse
>(
  variables: ReadSingleItemsSanctionSectorsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsSanctionSectorsResponse,
      ReadSingleItemsSanctionSectorsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsSanctionSectorsResponse,
    ReadSingleItemsSanctionSectorsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanction_sectors/{id}",
      operationId: "readSingleItemsSanctionSectors",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsSanctionSectors(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsSanctionTypesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsSanctionTypesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsSanctionTypesResponse = {
  data?: Schemas.ItemsSanctionTypes[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsSanctionTypesVariables = {
  queryParams?: ReadItemsSanctionTypesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the sanction_types items.
 */
export const fetchReadItemsSanctionTypes = (
  variables: ReadItemsSanctionTypesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsSanctionTypesResponse,
    ReadItemsSanctionTypesError,
    undefined,
    {},
    ReadItemsSanctionTypesQueryParams,
    {}
  >({ url: "/items/sanction_types", method: "get", ...variables, signal });

/**
 * List the sanction_types items.
 */
export const useReadItemsSanctionTypes = <
  TData = ReadItemsSanctionTypesResponse
>(
  variables: ReadItemsSanctionTypesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsSanctionTypesResponse,
      ReadItemsSanctionTypesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsSanctionTypesResponse,
    ReadItemsSanctionTypesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanction_types",
      operationId: "readItemsSanctionTypes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsSanctionTypes({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsSanctionTypesPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsSanctionTypesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsSanctionTypesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsSanctionTypesResponse = {
  data?: Schemas.ItemsSanctionTypes;
};

export type ReadSingleItemsSanctionTypesVariables = {
  pathParams: ReadSingleItemsSanctionTypesPathParams;
  queryParams?: ReadSingleItemsSanctionTypesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single sanction_types item by unique identifier.
 */
export const fetchReadSingleItemsSanctionTypes = (
  variables: ReadSingleItemsSanctionTypesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsSanctionTypesResponse,
    ReadSingleItemsSanctionTypesError,
    undefined,
    {},
    ReadSingleItemsSanctionTypesQueryParams,
    ReadSingleItemsSanctionTypesPathParams
  >({ url: "/items/sanction_types/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single sanction_types item by unique identifier.
 */
export const useReadSingleItemsSanctionTypes = <
  TData = ReadSingleItemsSanctionTypesResponse
>(
  variables: ReadSingleItemsSanctionTypesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsSanctionTypesResponse,
      ReadSingleItemsSanctionTypesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsSanctionTypesResponse,
    ReadSingleItemsSanctionTypesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanction_types/{id}",
      operationId: "readSingleItemsSanctionTypes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsSanctionTypes(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsSanctionsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsSanctionsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsSanctionsResponse = {
  data?: Schemas.ItemsSanctions[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsSanctionsVariables = {
  queryParams?: ReadItemsSanctionsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the sanctions items.
 */
export const fetchReadItemsSanctions = (
  variables: ReadItemsSanctionsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsSanctionsResponse,
    ReadItemsSanctionsError,
    undefined,
    {},
    ReadItemsSanctionsQueryParams,
    {}
  >({ url: "/items/sanctions", method: "get", ...variables, signal });

/**
 * List the sanctions items.
 */
export const useReadItemsSanctions = <TData = ReadItemsSanctionsResponse>(
  variables: ReadItemsSanctionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsSanctionsResponse,
      ReadItemsSanctionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsSanctionsResponse,
    ReadItemsSanctionsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanctions",
      operationId: "readItemsSanctions",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsSanctions({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsSanctionsPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsSanctionsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsSanctionsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsSanctionsResponse = {
  data?: Schemas.ItemsSanctions;
};

export type ReadSingleItemsSanctionsVariables = {
  pathParams: ReadSingleItemsSanctionsPathParams;
  queryParams?: ReadSingleItemsSanctionsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single sanctions item by unique identifier.
 */
export const fetchReadSingleItemsSanctions = (
  variables: ReadSingleItemsSanctionsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsSanctionsResponse,
    ReadSingleItemsSanctionsError,
    undefined,
    {},
    ReadSingleItemsSanctionsQueryParams,
    ReadSingleItemsSanctionsPathParams
  >({ url: "/items/sanctions/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single sanctions item by unique identifier.
 */
export const useReadSingleItemsSanctions = <
  TData = ReadSingleItemsSanctionsResponse
>(
  variables: ReadSingleItemsSanctionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsSanctionsResponse,
      ReadSingleItemsSanctionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsSanctionsResponse,
    ReadSingleItemsSanctionsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanctions/{id}",
      operationId: "readSingleItemsSanctions",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsSanctions(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsSanctionsSanctionPurposesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsSanctionsSanctionPurposesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsSanctionsSanctionPurposesResponse = {
  data?: Schemas.ItemsSanctionsSanctionPurposes[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsSanctionsSanctionPurposesVariables = {
  queryParams?: ReadItemsSanctionsSanctionPurposesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the sanctions_sanction_purposes items.
 */
export const fetchReadItemsSanctionsSanctionPurposes = (
  variables: ReadItemsSanctionsSanctionPurposesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsSanctionsSanctionPurposesResponse,
    ReadItemsSanctionsSanctionPurposesError,
    undefined,
    {},
    ReadItemsSanctionsSanctionPurposesQueryParams,
    {}
  >({
    url: "/items/sanctions_sanction_purposes",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the sanctions_sanction_purposes items.
 */
export const useReadItemsSanctionsSanctionPurposes = <
  TData = ReadItemsSanctionsSanctionPurposesResponse
>(
  variables: ReadItemsSanctionsSanctionPurposesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsSanctionsSanctionPurposesResponse,
      ReadItemsSanctionsSanctionPurposesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsSanctionsSanctionPurposesResponse,
    ReadItemsSanctionsSanctionPurposesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanctions_sanction_purposes",
      operationId: "readItemsSanctionsSanctionPurposes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsSanctionsSanctionPurposes(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsSanctionsSanctionPurposesPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsSanctionsSanctionPurposesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsSanctionsSanctionPurposesError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Responses.UnauthorizedError;
      }
    | {
        status: 404;
        payload: Responses.NotFoundError;
      }
  >;

export type ReadSingleItemsSanctionsSanctionPurposesResponse = {
  data?: Schemas.ItemsSanctionsSanctionPurposes;
};

export type ReadSingleItemsSanctionsSanctionPurposesVariables = {
  pathParams: ReadSingleItemsSanctionsSanctionPurposesPathParams;
  queryParams?: ReadSingleItemsSanctionsSanctionPurposesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single sanctions_sanction_purposes item by unique identifier.
 */
export const fetchReadSingleItemsSanctionsSanctionPurposes = (
  variables: ReadSingleItemsSanctionsSanctionPurposesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsSanctionsSanctionPurposesResponse,
    ReadSingleItemsSanctionsSanctionPurposesError,
    undefined,
    {},
    ReadSingleItemsSanctionsSanctionPurposesQueryParams,
    ReadSingleItemsSanctionsSanctionPurposesPathParams
  >({
    url: "/items/sanctions_sanction_purposes/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single sanctions_sanction_purposes item by unique identifier.
 */
export const useReadSingleItemsSanctionsSanctionPurposes = <
  TData = ReadSingleItemsSanctionsSanctionPurposesResponse
>(
  variables: ReadSingleItemsSanctionsSanctionPurposesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsSanctionsSanctionPurposesResponse,
      ReadSingleItemsSanctionsSanctionPurposesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsSanctionsSanctionPurposesResponse,
    ReadSingleItemsSanctionsSanctionPurposesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanctions_sanction_purposes/{id}",
      operationId: "readSingleItemsSanctionsSanctionPurposes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsSanctionsSanctionPurposes(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsWikiPageQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsWikiPageError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsWikiPageResponse = {
  data?: Schemas.ItemsWikiPage[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsWikiPageVariables = {
  queryParams?: ReadItemsWikiPageQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the wiki_page items.
 */
export const fetchReadItemsWikiPage = (
  variables: ReadItemsWikiPageVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsWikiPageResponse,
    ReadItemsWikiPageError,
    undefined,
    {},
    ReadItemsWikiPageQueryParams,
    {}
  >({ url: "/items/wiki_page", method: "get", ...variables, signal });

/**
 * List the wiki_page items.
 */
export const useReadItemsWikiPage = <TData = ReadItemsWikiPageResponse>(
  variables: ReadItemsWikiPageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsWikiPageResponse,
      ReadItemsWikiPageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsWikiPageResponse,
    ReadItemsWikiPageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/wiki_page",
      operationId: "readItemsWikiPage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsWikiPage({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsWikiPagePathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsWikiPageQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsWikiPageError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsWikiPageResponse = {
  data?: Schemas.ItemsWikiPage;
};

export type ReadSingleItemsWikiPageVariables = {
  pathParams: ReadSingleItemsWikiPagePathParams;
  queryParams?: ReadSingleItemsWikiPageQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single wiki_page item by unique identifier.
 */
export const fetchReadSingleItemsWikiPage = (
  variables: ReadSingleItemsWikiPageVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsWikiPageResponse,
    ReadSingleItemsWikiPageError,
    undefined,
    {},
    ReadSingleItemsWikiPageQueryParams,
    ReadSingleItemsWikiPagePathParams
  >({ url: "/items/wiki_page/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single wiki_page item by unique identifier.
 */
export const useReadSingleItemsWikiPage = <
  TData = ReadSingleItemsWikiPageResponse
>(
  variables: ReadSingleItemsWikiPageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsWikiPageResponse,
      ReadSingleItemsWikiPageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsWikiPageResponse,
    ReadSingleItemsWikiPageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/wiki_page/{id}",
      operationId: "readSingleItemsWikiPage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsWikiPage({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsWikiPageWikiCategoryQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsWikiPageWikiCategoryError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsWikiPageWikiCategoryResponse = {
  data?: Schemas.ItemsWikiPageWikiCategory[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsWikiPageWikiCategoryVariables = {
  queryParams?: ReadItemsWikiPageWikiCategoryQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the wiki_page_wiki_category items.
 */
export const fetchReadItemsWikiPageWikiCategory = (
  variables: ReadItemsWikiPageWikiCategoryVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsWikiPageWikiCategoryResponse,
    ReadItemsWikiPageWikiCategoryError,
    undefined,
    {},
    ReadItemsWikiPageWikiCategoryQueryParams,
    {}
  >({
    url: "/items/wiki_page_wiki_category",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the wiki_page_wiki_category items.
 */
export const useReadItemsWikiPageWikiCategory = <
  TData = ReadItemsWikiPageWikiCategoryResponse
>(
  variables: ReadItemsWikiPageWikiCategoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsWikiPageWikiCategoryResponse,
      ReadItemsWikiPageWikiCategoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsWikiPageWikiCategoryResponse,
    ReadItemsWikiPageWikiCategoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/wiki_page_wiki_category",
      operationId: "readItemsWikiPageWikiCategory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsWikiPageWikiCategory(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsWikiPageWikiCategoryPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsWikiPageWikiCategoryQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsWikiPageWikiCategoryError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsWikiPageWikiCategoryResponse = {
  data?: Schemas.ItemsWikiPageWikiCategory;
};

export type ReadSingleItemsWikiPageWikiCategoryVariables = {
  pathParams: ReadSingleItemsWikiPageWikiCategoryPathParams;
  queryParams?: ReadSingleItemsWikiPageWikiCategoryQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single wiki_page_wiki_category item by unique identifier.
 */
export const fetchReadSingleItemsWikiPageWikiCategory = (
  variables: ReadSingleItemsWikiPageWikiCategoryVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsWikiPageWikiCategoryResponse,
    ReadSingleItemsWikiPageWikiCategoryError,
    undefined,
    {},
    ReadSingleItemsWikiPageWikiCategoryQueryParams,
    ReadSingleItemsWikiPageWikiCategoryPathParams
  >({
    url: "/items/wiki_page_wiki_category/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single wiki_page_wiki_category item by unique identifier.
 */
export const useReadSingleItemsWikiPageWikiCategory = <
  TData = ReadSingleItemsWikiPageWikiCategoryResponse
>(
  variables: ReadSingleItemsWikiPageWikiCategoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsWikiPageWikiCategoryResponse,
      ReadSingleItemsWikiPageWikiCategoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsWikiPageWikiCategoryResponse,
    ReadSingleItemsWikiPageWikiCategoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/wiki_page_wiki_category/{id}",
      operationId: "readSingleItemsWikiPageWikiCategory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsWikiPageWikiCategory(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsSanctionsSanctionTypesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsSanctionsSanctionTypesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsSanctionsSanctionTypesResponse = {
  data?: Schemas.ItemsSanctionsSanctionTypes[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsSanctionsSanctionTypesVariables = {
  queryParams?: ReadItemsSanctionsSanctionTypesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the sanctions_sanction_types items.
 */
export const fetchReadItemsSanctionsSanctionTypes = (
  variables: ReadItemsSanctionsSanctionTypesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsSanctionsSanctionTypesResponse,
    ReadItemsSanctionsSanctionTypesError,
    undefined,
    {},
    ReadItemsSanctionsSanctionTypesQueryParams,
    {}
  >({
    url: "/items/sanctions_sanction_types",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the sanctions_sanction_types items.
 */
export const useReadItemsSanctionsSanctionTypes = <
  TData = ReadItemsSanctionsSanctionTypesResponse
>(
  variables: ReadItemsSanctionsSanctionTypesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsSanctionsSanctionTypesResponse,
      ReadItemsSanctionsSanctionTypesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsSanctionsSanctionTypesResponse,
    ReadItemsSanctionsSanctionTypesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanctions_sanction_types",
      operationId: "readItemsSanctionsSanctionTypes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsSanctionsSanctionTypes(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsSanctionsSanctionTypesPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsSanctionsSanctionTypesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsSanctionsSanctionTypesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsSanctionsSanctionTypesResponse = {
  data?: Schemas.ItemsSanctionsSanctionTypes;
};

export type ReadSingleItemsSanctionsSanctionTypesVariables = {
  pathParams: ReadSingleItemsSanctionsSanctionTypesPathParams;
  queryParams?: ReadSingleItemsSanctionsSanctionTypesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single sanctions_sanction_types item by unique identifier.
 */
export const fetchReadSingleItemsSanctionsSanctionTypes = (
  variables: ReadSingleItemsSanctionsSanctionTypesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsSanctionsSanctionTypesResponse,
    ReadSingleItemsSanctionsSanctionTypesError,
    undefined,
    {},
    ReadSingleItemsSanctionsSanctionTypesQueryParams,
    ReadSingleItemsSanctionsSanctionTypesPathParams
  >({
    url: "/items/sanctions_sanction_types/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single sanctions_sanction_types item by unique identifier.
 */
export const useReadSingleItemsSanctionsSanctionTypes = <
  TData = ReadSingleItemsSanctionsSanctionTypesResponse
>(
  variables: ReadSingleItemsSanctionsSanctionTypesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsSanctionsSanctionTypesResponse,
      ReadSingleItemsSanctionsSanctionTypesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsSanctionsSanctionTypesResponse,
    ReadSingleItemsSanctionsSanctionTypesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanctions_sanction_types/{id}",
      operationId: "readSingleItemsSanctionsSanctionTypes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsSanctionsSanctionTypes(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsWikiCategoryQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsWikiCategoryError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsWikiCategoryResponse = {
  data?: Schemas.ItemsWikiCategory[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsWikiCategoryVariables = {
  queryParams?: ReadItemsWikiCategoryQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the wiki_category items.
 */
export const fetchReadItemsWikiCategory = (
  variables: ReadItemsWikiCategoryVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsWikiCategoryResponse,
    ReadItemsWikiCategoryError,
    undefined,
    {},
    ReadItemsWikiCategoryQueryParams,
    {}
  >({ url: "/items/wiki_category", method: "get", ...variables, signal });

/**
 * List the wiki_category items.
 */
export const useReadItemsWikiCategory = <TData = ReadItemsWikiCategoryResponse>(
  variables: ReadItemsWikiCategoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsWikiCategoryResponse,
      ReadItemsWikiCategoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsWikiCategoryResponse,
    ReadItemsWikiCategoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/wiki_category",
      operationId: "readItemsWikiCategory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsWikiCategory({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsWikiCategoryPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsWikiCategoryQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsWikiCategoryError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsWikiCategoryResponse = {
  data?: Schemas.ItemsWikiCategory;
};

export type ReadSingleItemsWikiCategoryVariables = {
  pathParams: ReadSingleItemsWikiCategoryPathParams;
  queryParams?: ReadSingleItemsWikiCategoryQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single wiki_category item by unique identifier.
 */
export const fetchReadSingleItemsWikiCategory = (
  variables: ReadSingleItemsWikiCategoryVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsWikiCategoryResponse,
    ReadSingleItemsWikiCategoryError,
    undefined,
    {},
    ReadSingleItemsWikiCategoryQueryParams,
    ReadSingleItemsWikiCategoryPathParams
  >({ url: "/items/wiki_category/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single wiki_category item by unique identifier.
 */
export const useReadSingleItemsWikiCategory = <
  TData = ReadSingleItemsWikiCategoryResponse
>(
  variables: ReadSingleItemsWikiCategoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsWikiCategoryResponse,
      ReadSingleItemsWikiCategoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsWikiCategoryResponse,
    ReadSingleItemsWikiCategoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/wiki_category/{id}",
      operationId: "readSingleItemsWikiCategory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsWikiCategory(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsArticleSourcesArticlesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsArticleSourcesArticlesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsArticleSourcesArticlesResponse = {
  data?: Schemas.ItemsArticleSourcesArticles[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsArticleSourcesArticlesVariables = {
  queryParams?: ReadItemsArticleSourcesArticlesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the article_sources_articles items.
 */
export const fetchReadItemsArticleSourcesArticles = (
  variables: ReadItemsArticleSourcesArticlesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsArticleSourcesArticlesResponse,
    ReadItemsArticleSourcesArticlesError,
    undefined,
    {},
    ReadItemsArticleSourcesArticlesQueryParams,
    {}
  >({
    url: "/items/article_sources_articles",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the article_sources_articles items.
 */
export const useReadItemsArticleSourcesArticles = <
  TData = ReadItemsArticleSourcesArticlesResponse
>(
  variables: ReadItemsArticleSourcesArticlesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsArticleSourcesArticlesResponse,
      ReadItemsArticleSourcesArticlesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsArticleSourcesArticlesResponse,
    ReadItemsArticleSourcesArticlesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/article_sources_articles",
      operationId: "readItemsArticleSourcesArticles",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsArticleSourcesArticles(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsArticleSourcesArticlesPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsArticleSourcesArticlesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsArticleSourcesArticlesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsArticleSourcesArticlesResponse = {
  data?: Schemas.ItemsArticleSourcesArticles;
};

export type ReadSingleItemsArticleSourcesArticlesVariables = {
  pathParams: ReadSingleItemsArticleSourcesArticlesPathParams;
  queryParams?: ReadSingleItemsArticleSourcesArticlesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single article_sources_articles item by unique identifier.
 */
export const fetchReadSingleItemsArticleSourcesArticles = (
  variables: ReadSingleItemsArticleSourcesArticlesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsArticleSourcesArticlesResponse,
    ReadSingleItemsArticleSourcesArticlesError,
    undefined,
    {},
    ReadSingleItemsArticleSourcesArticlesQueryParams,
    ReadSingleItemsArticleSourcesArticlesPathParams
  >({
    url: "/items/article_sources_articles/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single article_sources_articles item by unique identifier.
 */
export const useReadSingleItemsArticleSourcesArticles = <
  TData = ReadSingleItemsArticleSourcesArticlesResponse
>(
  variables: ReadSingleItemsArticleSourcesArticlesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsArticleSourcesArticlesResponse,
      ReadSingleItemsArticleSourcesArticlesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsArticleSourcesArticlesResponse,
    ReadSingleItemsArticleSourcesArticlesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/article_sources_articles/{id}",
      operationId: "readSingleItemsArticleSourcesArticles",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsArticleSourcesArticles(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsHomepageBlocksQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsHomepageBlocksError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsHomepageBlocksResponse = {
  data?: Schemas.ItemsHomepageBlocks[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsHomepageBlocksVariables = {
  queryParams?: ReadItemsHomepageBlocksQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the homepage_blocks items.
 */
export const fetchReadItemsHomepageBlocks = (
  variables: ReadItemsHomepageBlocksVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsHomepageBlocksResponse,
    ReadItemsHomepageBlocksError,
    undefined,
    {},
    ReadItemsHomepageBlocksQueryParams,
    {}
  >({ url: "/items/homepage_blocks", method: "get", ...variables, signal });

/**
 * List the homepage_blocks items.
 */
export const useReadItemsHomepageBlocks = <
  TData = ReadItemsHomepageBlocksResponse
>(
  variables: ReadItemsHomepageBlocksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsHomepageBlocksResponse,
      ReadItemsHomepageBlocksError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsHomepageBlocksResponse,
    ReadItemsHomepageBlocksError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/homepage_blocks",
      operationId: "readItemsHomepageBlocks",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsHomepageBlocks({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsHomepageBlocksPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsHomepageBlocksQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsHomepageBlocksError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsHomepageBlocksResponse = {
  data?: Schemas.ItemsHomepageBlocks;
};

export type ReadSingleItemsHomepageBlocksVariables = {
  pathParams: ReadSingleItemsHomepageBlocksPathParams;
  queryParams?: ReadSingleItemsHomepageBlocksQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single homepage_blocks item by unique identifier.
 */
export const fetchReadSingleItemsHomepageBlocks = (
  variables: ReadSingleItemsHomepageBlocksVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsHomepageBlocksResponse,
    ReadSingleItemsHomepageBlocksError,
    undefined,
    {},
    ReadSingleItemsHomepageBlocksQueryParams,
    ReadSingleItemsHomepageBlocksPathParams
  >({
    url: "/items/homepage_blocks/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single homepage_blocks item by unique identifier.
 */
export const useReadSingleItemsHomepageBlocks = <
  TData = ReadSingleItemsHomepageBlocksResponse
>(
  variables: ReadSingleItemsHomepageBlocksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsHomepageBlocksResponse,
      ReadSingleItemsHomepageBlocksError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsHomepageBlocksResponse,
    ReadSingleItemsHomepageBlocksError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/homepage_blocks/{id}",
      operationId: "readSingleItemsHomepageBlocks",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsHomepageBlocks(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsSanctionPurposesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsSanctionPurposesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsSanctionPurposesResponse = {
  data?: Schemas.ItemsSanctionPurposes[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsSanctionPurposesVariables = {
  queryParams?: ReadItemsSanctionPurposesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the sanction_purposes items.
 */
export const fetchReadItemsSanctionPurposes = (
  variables: ReadItemsSanctionPurposesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsSanctionPurposesResponse,
    ReadItemsSanctionPurposesError,
    undefined,
    {},
    ReadItemsSanctionPurposesQueryParams,
    {}
  >({ url: "/items/sanction_purposes", method: "get", ...variables, signal });

/**
 * List the sanction_purposes items.
 */
export const useReadItemsSanctionPurposes = <
  TData = ReadItemsSanctionPurposesResponse
>(
  variables: ReadItemsSanctionPurposesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsSanctionPurposesResponse,
      ReadItemsSanctionPurposesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsSanctionPurposesResponse,
    ReadItemsSanctionPurposesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanction_purposes",
      operationId: "readItemsSanctionPurposes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsSanctionPurposes(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsSanctionPurposesPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsSanctionPurposesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsSanctionPurposesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsSanctionPurposesResponse = {
  data?: Schemas.ItemsSanctionPurposes;
};

export type ReadSingleItemsSanctionPurposesVariables = {
  pathParams: ReadSingleItemsSanctionPurposesPathParams;
  queryParams?: ReadSingleItemsSanctionPurposesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single sanction_purposes item by unique identifier.
 */
export const fetchReadSingleItemsSanctionPurposes = (
  variables: ReadSingleItemsSanctionPurposesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsSanctionPurposesResponse,
    ReadSingleItemsSanctionPurposesError,
    undefined,
    {},
    ReadSingleItemsSanctionPurposesQueryParams,
    ReadSingleItemsSanctionPurposesPathParams
  >({
    url: "/items/sanction_purposes/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single sanction_purposes item by unique identifier.
 */
export const useReadSingleItemsSanctionPurposes = <
  TData = ReadSingleItemsSanctionPurposesResponse
>(
  variables: ReadSingleItemsSanctionPurposesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsSanctionPurposesResponse,
      ReadSingleItemsSanctionPurposesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsSanctionPurposesResponse,
    ReadSingleItemsSanctionPurposesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanction_purposes/{id}",
      operationId: "readSingleItemsSanctionPurposes",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsSanctionPurposes(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsSanctionsSanctionSectorsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsSanctionsSanctionSectorsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsSanctionsSanctionSectorsResponse = {
  data?: Schemas.ItemsSanctionsSanctionSectors[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsSanctionsSanctionSectorsVariables = {
  queryParams?: ReadItemsSanctionsSanctionSectorsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the sanctions_sanction_sectors items.
 */
export const fetchReadItemsSanctionsSanctionSectors = (
  variables: ReadItemsSanctionsSanctionSectorsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsSanctionsSanctionSectorsResponse,
    ReadItemsSanctionsSanctionSectorsError,
    undefined,
    {},
    ReadItemsSanctionsSanctionSectorsQueryParams,
    {}
  >({
    url: "/items/sanctions_sanction_sectors",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the sanctions_sanction_sectors items.
 */
export const useReadItemsSanctionsSanctionSectors = <
  TData = ReadItemsSanctionsSanctionSectorsResponse
>(
  variables: ReadItemsSanctionsSanctionSectorsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsSanctionsSanctionSectorsResponse,
      ReadItemsSanctionsSanctionSectorsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsSanctionsSanctionSectorsResponse,
    ReadItemsSanctionsSanctionSectorsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanctions_sanction_sectors",
      operationId: "readItemsSanctionsSanctionSectors",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsSanctionsSanctionSectors(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsSanctionsSanctionSectorsPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsSanctionsSanctionSectorsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsSanctionsSanctionSectorsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsSanctionsSanctionSectorsResponse = {
  data?: Schemas.ItemsSanctionsSanctionSectors;
};

export type ReadSingleItemsSanctionsSanctionSectorsVariables = {
  pathParams: ReadSingleItemsSanctionsSanctionSectorsPathParams;
  queryParams?: ReadSingleItemsSanctionsSanctionSectorsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single sanctions_sanction_sectors item by unique identifier.
 */
export const fetchReadSingleItemsSanctionsSanctionSectors = (
  variables: ReadSingleItemsSanctionsSanctionSectorsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsSanctionsSanctionSectorsResponse,
    ReadSingleItemsSanctionsSanctionSectorsError,
    undefined,
    {},
    ReadSingleItemsSanctionsSanctionSectorsQueryParams,
    ReadSingleItemsSanctionsSanctionSectorsPathParams
  >({
    url: "/items/sanctions_sanction_sectors/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single sanctions_sanction_sectors item by unique identifier.
 */
export const useReadSingleItemsSanctionsSanctionSectors = <
  TData = ReadSingleItemsSanctionsSanctionSectorsResponse
>(
  variables: ReadSingleItemsSanctionsSanctionSectorsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsSanctionsSanctionSectorsResponse,
      ReadSingleItemsSanctionsSanctionSectorsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsSanctionsSanctionSectorsResponse,
    ReadSingleItemsSanctionsSanctionSectorsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/sanctions_sanction_sectors/{id}",
      operationId: "readSingleItemsSanctionsSanctionSectors",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsSanctionsSanctionSectors(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type GetFilesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
};

export type GetFilesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type GetFilesResponse = {
  data?: Schemas.Files[];
  meta?: Schemas.XMetadata;
};

export type GetFilesVariables = {
  queryParams?: GetFilesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the files.
 */
export const fetchGetFiles = (
  variables: GetFilesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    GetFilesResponse,
    GetFilesError,
    undefined,
    {},
    GetFilesQueryParams,
    {}
  >({ url: "/files", method: "get", ...variables, signal });

/**
 * List the files.
 */
export const useGetFiles = <TData = GetFilesResponse>(
  variables: GetFilesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetFilesResponse, GetFilesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<GetFilesResponse, GetFilesError, TData>({
    queryKey: queryKeyFn({
      path: "/files",
      operationId: "getFiles",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetFiles({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetFilePathParams = {
  /**
   * Unique identifier for the object.
   *
   * @example 8cbb43fe-4cdf-4991-8352-c461779cec02
   */
  id: string;
};

export type GetFileQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
};

export type GetFileError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type GetFileResponse = {
  data?: Schemas.Files;
};

export type GetFileVariables = {
  pathParams: GetFilePathParams;
  queryParams?: GetFileQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single file by unique identifier.
 */
export const fetchGetFile = (
  variables: GetFileVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    GetFileResponse,
    GetFileError,
    undefined,
    {},
    GetFileQueryParams,
    GetFilePathParams
  >({ url: "/files/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single file by unique identifier.
 */
export const useGetFile = <TData = GetFileResponse>(
  variables: GetFileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetFileResponse, GetFileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<GetFileResponse, GetFileError, TData>({
    queryKey: queryKeyFn({
      path: "/files/{id}",
      operationId: "getFile",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetFile({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsArticleSourcesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsArticleSourcesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsArticleSourcesResponse = {
  data?: Schemas.ItemsArticleSources[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsArticleSourcesVariables = {
  queryParams?: ReadItemsArticleSourcesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the article_sources items.
 */
export const fetchReadItemsArticleSources = (
  variables: ReadItemsArticleSourcesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsArticleSourcesResponse,
    ReadItemsArticleSourcesError,
    undefined,
    {},
    ReadItemsArticleSourcesQueryParams,
    {}
  >({ url: "/items/article_sources", method: "get", ...variables, signal });

/**
 * List the article_sources items.
 */
export const useReadItemsArticleSources = <
  TData = ReadItemsArticleSourcesResponse
>(
  variables: ReadItemsArticleSourcesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsArticleSourcesResponse,
      ReadItemsArticleSourcesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsArticleSourcesResponse,
    ReadItemsArticleSourcesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/article_sources",
      operationId: "readItemsArticleSources",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsArticleSources({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsArticleSourcesPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsArticleSourcesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsArticleSourcesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsArticleSourcesResponse = {
  data?: Schemas.ItemsArticleSources;
};

export type ReadSingleItemsArticleSourcesVariables = {
  pathParams: ReadSingleItemsArticleSourcesPathParams;
  queryParams?: ReadSingleItemsArticleSourcesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single article_sources item by unique identifier.
 */
export const fetchReadSingleItemsArticleSources = (
  variables: ReadSingleItemsArticleSourcesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsArticleSourcesResponse,
    ReadSingleItemsArticleSourcesError,
    undefined,
    {},
    ReadSingleItemsArticleSourcesQueryParams,
    ReadSingleItemsArticleSourcesPathParams
  >({
    url: "/items/article_sources/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single article_sources item by unique identifier.
 */
export const useReadSingleItemsArticleSources = <
  TData = ReadSingleItemsArticleSourcesResponse
>(
  variables: ReadSingleItemsArticleSourcesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsArticleSourcesResponse,
      ReadSingleItemsArticleSourcesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsArticleSourcesResponse,
    ReadSingleItemsArticleSourcesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/article_sources/{id}",
      operationId: "readSingleItemsArticleSources",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsArticleSources(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsArticlesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsArticlesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsArticlesResponse = {
  data?: Schemas.ItemsArticles[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsArticlesVariables = {
  queryParams?: ReadItemsArticlesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the articles items.
 */
export const fetchReadItemsArticles = (
  variables: ReadItemsArticlesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsArticlesResponse,
    ReadItemsArticlesError,
    undefined,
    {},
    ReadItemsArticlesQueryParams,
    {}
  >({ url: "/items/articles", method: "get", ...variables, signal });

/**
 * List the articles items.
 */
export const useReadItemsArticles = <TData = ReadItemsArticlesResponse>(
  variables: ReadItemsArticlesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsArticlesResponse,
      ReadItemsArticlesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsArticlesResponse,
    ReadItemsArticlesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/articles",
      operationId: "readItemsArticles",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsArticles({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsArticlesPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsArticlesQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsArticlesError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsArticlesResponse = {
  data?: Schemas.ItemsArticles;
};

export type ReadSingleItemsArticlesVariables = {
  pathParams: ReadSingleItemsArticlesPathParams;
  queryParams?: ReadSingleItemsArticlesQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single articles item by unique identifier.
 */
export const fetchReadSingleItemsArticles = (
  variables: ReadSingleItemsArticlesVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsArticlesResponse,
    ReadSingleItemsArticlesError,
    undefined,
    {},
    ReadSingleItemsArticlesQueryParams,
    ReadSingleItemsArticlesPathParams
  >({ url: "/items/articles/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single articles item by unique identifier.
 */
export const useReadSingleItemsArticles = <
  TData = ReadSingleItemsArticlesResponse
>(
  variables: ReadSingleItemsArticlesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsArticlesResponse,
      ReadSingleItemsArticlesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsArticlesResponse,
    ReadSingleItemsArticlesError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/articles/{id}",
      operationId: "readSingleItemsArticles",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsArticles({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsArticlesDirectusUsersQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsArticlesDirectusUsersError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsArticlesDirectusUsersResponse = {
  data?: Schemas.ItemsArticlesDirectusUsers[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsArticlesDirectusUsersVariables = {
  queryParams?: ReadItemsArticlesDirectusUsersQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the articles_directus_users items.
 */
export const fetchReadItemsArticlesDirectusUsers = (
  variables: ReadItemsArticlesDirectusUsersVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsArticlesDirectusUsersResponse,
    ReadItemsArticlesDirectusUsersError,
    undefined,
    {},
    ReadItemsArticlesDirectusUsersQueryParams,
    {}
  >({
    url: "/items/articles_directus_users",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the articles_directus_users items.
 */
export const useReadItemsArticlesDirectusUsers = <
  TData = ReadItemsArticlesDirectusUsersResponse
>(
  variables: ReadItemsArticlesDirectusUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsArticlesDirectusUsersResponse,
      ReadItemsArticlesDirectusUsersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsArticlesDirectusUsersResponse,
    ReadItemsArticlesDirectusUsersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/articles_directus_users",
      operationId: "readItemsArticlesDirectusUsers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsArticlesDirectusUsers(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsArticlesDirectusUsersPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsArticlesDirectusUsersQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsArticlesDirectusUsersError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsArticlesDirectusUsersResponse = {
  data?: Schemas.ItemsArticlesDirectusUsers;
};

export type ReadSingleItemsArticlesDirectusUsersVariables = {
  pathParams: ReadSingleItemsArticlesDirectusUsersPathParams;
  queryParams?: ReadSingleItemsArticlesDirectusUsersQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single articles_directus_users item by unique identifier.
 */
export const fetchReadSingleItemsArticlesDirectusUsers = (
  variables: ReadSingleItemsArticlesDirectusUsersVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsArticlesDirectusUsersResponse,
    ReadSingleItemsArticlesDirectusUsersError,
    undefined,
    {},
    ReadSingleItemsArticlesDirectusUsersQueryParams,
    ReadSingleItemsArticlesDirectusUsersPathParams
  >({
    url: "/items/articles_directus_users/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single articles_directus_users item by unique identifier.
 */
export const useReadSingleItemsArticlesDirectusUsers = <
  TData = ReadSingleItemsArticlesDirectusUsersResponse
>(
  variables: ReadSingleItemsArticlesDirectusUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsArticlesDirectusUsersResponse,
      ReadSingleItemsArticlesDirectusUsersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsArticlesDirectusUsersResponse,
    ReadSingleItemsArticlesDirectusUsersError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/articles_directus_users/{id}",
      operationId: "readSingleItemsArticlesDirectusUsers",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsArticlesDirectusUsers(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsArticlesEscalationPathwaysQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsArticlesEscalationPathwaysError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsArticlesEscalationPathwaysResponse = {
  data?: Schemas.ItemsArticlesEscalationPathways[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsArticlesEscalationPathwaysVariables = {
  queryParams?: ReadItemsArticlesEscalationPathwaysQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the articles_escalation_pathways items.
 */
export const fetchReadItemsArticlesEscalationPathways = (
  variables: ReadItemsArticlesEscalationPathwaysVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsArticlesEscalationPathwaysResponse,
    ReadItemsArticlesEscalationPathwaysError,
    undefined,
    {},
    ReadItemsArticlesEscalationPathwaysQueryParams,
    {}
  >({
    url: "/items/articles_escalation_pathways",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the articles_escalation_pathways items.
 */
export const useReadItemsArticlesEscalationPathways = <
  TData = ReadItemsArticlesEscalationPathwaysResponse
>(
  variables: ReadItemsArticlesEscalationPathwaysVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsArticlesEscalationPathwaysResponse,
      ReadItemsArticlesEscalationPathwaysError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsArticlesEscalationPathwaysResponse,
    ReadItemsArticlesEscalationPathwaysError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/articles_escalation_pathways",
      operationId: "readItemsArticlesEscalationPathways",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsArticlesEscalationPathways(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsArticlesEscalationPathwaysPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsArticlesEscalationPathwaysQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsArticlesEscalationPathwaysError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Responses.UnauthorizedError;
      }
    | {
        status: 404;
        payload: Responses.NotFoundError;
      }
  >;

export type ReadSingleItemsArticlesEscalationPathwaysResponse = {
  data?: Schemas.ItemsArticlesEscalationPathways;
};

export type ReadSingleItemsArticlesEscalationPathwaysVariables = {
  pathParams: ReadSingleItemsArticlesEscalationPathwaysPathParams;
  queryParams?: ReadSingleItemsArticlesEscalationPathwaysQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single articles_escalation_pathways item by unique identifier.
 */
export const fetchReadSingleItemsArticlesEscalationPathways = (
  variables: ReadSingleItemsArticlesEscalationPathwaysVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsArticlesEscalationPathwaysResponse,
    ReadSingleItemsArticlesEscalationPathwaysError,
    undefined,
    {},
    ReadSingleItemsArticlesEscalationPathwaysQueryParams,
    ReadSingleItemsArticlesEscalationPathwaysPathParams
  >({
    url: "/items/articles_escalation_pathways/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single articles_escalation_pathways item by unique identifier.
 */
export const useReadSingleItemsArticlesEscalationPathways = <
  TData = ReadSingleItemsArticlesEscalationPathwaysResponse
>(
  variables: ReadSingleItemsArticlesEscalationPathwaysVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsArticlesEscalationPathwaysResponse,
      ReadSingleItemsArticlesEscalationPathwaysError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsArticlesEscalationPathwaysResponse,
    ReadSingleItemsArticlesEscalationPathwaysError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/articles_escalation_pathways/{id}",
      operationId: "readSingleItemsArticlesEscalationPathways",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsArticlesEscalationPathways(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsBlockCardgroupQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsBlockCardgroupError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsBlockCardgroupResponse = {
  data?: Schemas.ItemsBlockCardgroup[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsBlockCardgroupVariables = {
  queryParams?: ReadItemsBlockCardgroupQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the block_cardgroup items.
 */
export const fetchReadItemsBlockCardgroup = (
  variables: ReadItemsBlockCardgroupVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsBlockCardgroupResponse,
    ReadItemsBlockCardgroupError,
    undefined,
    {},
    ReadItemsBlockCardgroupQueryParams,
    {}
  >({ url: "/items/block_cardgroup", method: "get", ...variables, signal });

/**
 * List the block_cardgroup items.
 */
export const useReadItemsBlockCardgroup = <
  TData = ReadItemsBlockCardgroupResponse
>(
  variables: ReadItemsBlockCardgroupVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsBlockCardgroupResponse,
      ReadItemsBlockCardgroupError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsBlockCardgroupResponse,
    ReadItemsBlockCardgroupError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_cardgroup",
      operationId: "readItemsBlockCardgroup",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsBlockCardgroup({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsBlockCardgroupPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsBlockCardgroupQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsBlockCardgroupError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsBlockCardgroupResponse = {
  data?: Schemas.ItemsBlockCardgroup;
};

export type ReadSingleItemsBlockCardgroupVariables = {
  pathParams: ReadSingleItemsBlockCardgroupPathParams;
  queryParams?: ReadSingleItemsBlockCardgroupQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single block_cardgroup item by unique identifier.
 */
export const fetchReadSingleItemsBlockCardgroup = (
  variables: ReadSingleItemsBlockCardgroupVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsBlockCardgroupResponse,
    ReadSingleItemsBlockCardgroupError,
    undefined,
    {},
    ReadSingleItemsBlockCardgroupQueryParams,
    ReadSingleItemsBlockCardgroupPathParams
  >({
    url: "/items/block_cardgroup/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single block_cardgroup item by unique identifier.
 */
export const useReadSingleItemsBlockCardgroup = <
  TData = ReadSingleItemsBlockCardgroupResponse
>(
  variables: ReadSingleItemsBlockCardgroupVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsBlockCardgroupResponse,
      ReadSingleItemsBlockCardgroupError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsBlockCardgroupResponse,
    ReadSingleItemsBlockCardgroupError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_cardgroup/{id}",
      operationId: "readSingleItemsBlockCardgroup",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsBlockCardgroup(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsBlockCardgroupCardsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsBlockCardgroupCardsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsBlockCardgroupCardsResponse = {
  data?: Schemas.ItemsBlockCardgroupCards[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsBlockCardgroupCardsVariables = {
  queryParams?: ReadItemsBlockCardgroupCardsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the block_cardgroup_cards items.
 */
export const fetchReadItemsBlockCardgroupCards = (
  variables: ReadItemsBlockCardgroupCardsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsBlockCardgroupCardsResponse,
    ReadItemsBlockCardgroupCardsError,
    undefined,
    {},
    ReadItemsBlockCardgroupCardsQueryParams,
    {}
  >({
    url: "/items/block_cardgroup_cards",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the block_cardgroup_cards items.
 */
export const useReadItemsBlockCardgroupCards = <
  TData = ReadItemsBlockCardgroupCardsResponse
>(
  variables: ReadItemsBlockCardgroupCardsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsBlockCardgroupCardsResponse,
      ReadItemsBlockCardgroupCardsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsBlockCardgroupCardsResponse,
    ReadItemsBlockCardgroupCardsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_cardgroup_cards",
      operationId: "readItemsBlockCardgroupCards",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsBlockCardgroupCards(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsBlockCardgroupCardsPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsBlockCardgroupCardsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsBlockCardgroupCardsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsBlockCardgroupCardsResponse = {
  data?: Schemas.ItemsBlockCardgroupCards;
};

export type ReadSingleItemsBlockCardgroupCardsVariables = {
  pathParams: ReadSingleItemsBlockCardgroupCardsPathParams;
  queryParams?: ReadSingleItemsBlockCardgroupCardsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single block_cardgroup_cards item by unique identifier.
 */
export const fetchReadSingleItemsBlockCardgroupCards = (
  variables: ReadSingleItemsBlockCardgroupCardsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsBlockCardgroupCardsResponse,
    ReadSingleItemsBlockCardgroupCardsError,
    undefined,
    {},
    ReadSingleItemsBlockCardgroupCardsQueryParams,
    ReadSingleItemsBlockCardgroupCardsPathParams
  >({
    url: "/items/block_cardgroup_cards/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single block_cardgroup_cards item by unique identifier.
 */
export const useReadSingleItemsBlockCardgroupCards = <
  TData = ReadSingleItemsBlockCardgroupCardsResponse
>(
  variables: ReadSingleItemsBlockCardgroupCardsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsBlockCardgroupCardsResponse,
      ReadSingleItemsBlockCardgroupCardsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsBlockCardgroupCardsResponse,
    ReadSingleItemsBlockCardgroupCardsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_cardgroup_cards/{id}",
      operationId: "readSingleItemsBlockCardgroupCards",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsBlockCardgroupCards(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsBlockCardgroupCMSPageQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsBlockCardgroupCMSPageError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsBlockCardgroupCMSPageResponse = {
  data?: Schemas.ItemsBlockCardgroupCMSPage[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsBlockCardgroupCMSPageVariables = {
  queryParams?: ReadItemsBlockCardgroupCMSPageQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the block_cardgroup_cms_page items.
 */
export const fetchReadItemsBlockCardgroupCMSPage = (
  variables: ReadItemsBlockCardgroupCMSPageVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsBlockCardgroupCMSPageResponse,
    ReadItemsBlockCardgroupCMSPageError,
    undefined,
    {},
    ReadItemsBlockCardgroupCMSPageQueryParams,
    {}
  >({
    url: "/items/block_cardgroup_cms_page",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the block_cardgroup_cms_page items.
 */
export const useReadItemsBlockCardgroupCMSPage = <
  TData = ReadItemsBlockCardgroupCMSPageResponse
>(
  variables: ReadItemsBlockCardgroupCMSPageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsBlockCardgroupCMSPageResponse,
      ReadItemsBlockCardgroupCMSPageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsBlockCardgroupCMSPageResponse,
    ReadItemsBlockCardgroupCMSPageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_cardgroup_cms_page",
      operationId: "readItemsBlockCardgroupCMSPage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsBlockCardgroupCMSPage(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsBlockCardgroupCMSPagePathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsBlockCardgroupCMSPageQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsBlockCardgroupCMSPageError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsBlockCardgroupCMSPageResponse = {
  data?: Schemas.ItemsBlockCardgroupCMSPage;
};

export type ReadSingleItemsBlockCardgroupCMSPageVariables = {
  pathParams: ReadSingleItemsBlockCardgroupCMSPagePathParams;
  queryParams?: ReadSingleItemsBlockCardgroupCMSPageQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single block_cardgroup_cms_page item by unique identifier.
 */
export const fetchReadSingleItemsBlockCardgroupCMSPage = (
  variables: ReadSingleItemsBlockCardgroupCMSPageVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsBlockCardgroupCMSPageResponse,
    ReadSingleItemsBlockCardgroupCMSPageError,
    undefined,
    {},
    ReadSingleItemsBlockCardgroupCMSPageQueryParams,
    ReadSingleItemsBlockCardgroupCMSPagePathParams
  >({
    url: "/items/block_cardgroup_cms_page/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single block_cardgroup_cms_page item by unique identifier.
 */
export const useReadSingleItemsBlockCardgroupCMSPage = <
  TData = ReadSingleItemsBlockCardgroupCMSPageResponse
>(
  variables: ReadSingleItemsBlockCardgroupCMSPageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsBlockCardgroupCMSPageResponse,
      ReadSingleItemsBlockCardgroupCMSPageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsBlockCardgroupCMSPageResponse,
    ReadSingleItemsBlockCardgroupCMSPageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_cardgroup_cms_page/{id}",
      operationId: "readSingleItemsBlockCardgroupCMSPage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsBlockCardgroupCMSPage(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsBlockHeroQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsBlockHeroError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsBlockHeroResponse = {
  data?: Schemas.ItemsBlockHero[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsBlockHeroVariables = {
  queryParams?: ReadItemsBlockHeroQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the block_hero items.
 */
export const fetchReadItemsBlockHero = (
  variables: ReadItemsBlockHeroVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsBlockHeroResponse,
    ReadItemsBlockHeroError,
    undefined,
    {},
    ReadItemsBlockHeroQueryParams,
    {}
  >({ url: "/items/block_hero", method: "get", ...variables, signal });

/**
 * List the block_hero items.
 */
export const useReadItemsBlockHero = <TData = ReadItemsBlockHeroResponse>(
  variables: ReadItemsBlockHeroVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsBlockHeroResponse,
      ReadItemsBlockHeroError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsBlockHeroResponse,
    ReadItemsBlockHeroError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_hero",
      operationId: "readItemsBlockHero",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsBlockHero({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsBlockHeroPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsBlockHeroQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsBlockHeroError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsBlockHeroResponse = {
  data?: Schemas.ItemsBlockHero;
};

export type ReadSingleItemsBlockHeroVariables = {
  pathParams: ReadSingleItemsBlockHeroPathParams;
  queryParams?: ReadSingleItemsBlockHeroQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single block_hero item by unique identifier.
 */
export const fetchReadSingleItemsBlockHero = (
  variables: ReadSingleItemsBlockHeroVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsBlockHeroResponse,
    ReadSingleItemsBlockHeroError,
    undefined,
    {},
    ReadSingleItemsBlockHeroQueryParams,
    ReadSingleItemsBlockHeroPathParams
  >({ url: "/items/block_hero/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single block_hero item by unique identifier.
 */
export const useReadSingleItemsBlockHero = <
  TData = ReadSingleItemsBlockHeroResponse
>(
  variables: ReadSingleItemsBlockHeroVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsBlockHeroResponse,
      ReadSingleItemsBlockHeroError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsBlockHeroResponse,
    ReadSingleItemsBlockHeroError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_hero/{id}",
      operationId: "readSingleItemsBlockHero",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsBlockHero(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsCMSPageQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsCMSPageError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsCMSPageResponse = {
  data?: Schemas.ItemsCMSPage[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsCMSPageVariables = {
  queryParams?: ReadItemsCMSPageQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the cms_page items.
 */
export const fetchReadItemsCMSPage = (
  variables: ReadItemsCMSPageVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsCMSPageResponse,
    ReadItemsCMSPageError,
    undefined,
    {},
    ReadItemsCMSPageQueryParams,
    {}
  >({ url: "/items/cms_page", method: "get", ...variables, signal });

/**
 * List the cms_page items.
 */
export const useReadItemsCMSPage = <TData = ReadItemsCMSPageResponse>(
  variables: ReadItemsCMSPageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsCMSPageResponse,
      ReadItemsCMSPageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsCMSPageResponse,
    ReadItemsCMSPageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/cms_page",
      operationId: "readItemsCMSPage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsCMSPage({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsCMSPagePathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsCMSPageQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsCMSPageError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsCMSPageResponse = {
  data?: Schemas.ItemsCMSPage;
};

export type ReadSingleItemsCMSPageVariables = {
  pathParams: ReadSingleItemsCMSPagePathParams;
  queryParams?: ReadSingleItemsCMSPageQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single cms_page item by unique identifier.
 */
export const fetchReadSingleItemsCMSPage = (
  variables: ReadSingleItemsCMSPageVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsCMSPageResponse,
    ReadSingleItemsCMSPageError,
    undefined,
    {},
    ReadSingleItemsCMSPageQueryParams,
    ReadSingleItemsCMSPagePathParams
  >({ url: "/items/cms_page/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single cms_page item by unique identifier.
 */
export const useReadSingleItemsCMSPage = <
  TData = ReadSingleItemsCMSPageResponse
>(
  variables: ReadSingleItemsCMSPageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsCMSPageResponse,
      ReadSingleItemsCMSPageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsCMSPageResponse,
    ReadSingleItemsCMSPageError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/cms_page/{id}",
      operationId: "readSingleItemsCMSPage",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsCMSPage({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsBlockRichtextQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsBlockRichtextError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsBlockRichtextResponse = {
  data?: Schemas.ItemsBlockRichtext[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsBlockRichtextVariables = {
  queryParams?: ReadItemsBlockRichtextQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the block_richtext items.
 */
export const fetchReadItemsBlockRichtext = (
  variables: ReadItemsBlockRichtextVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsBlockRichtextResponse,
    ReadItemsBlockRichtextError,
    undefined,
    {},
    ReadItemsBlockRichtextQueryParams,
    {}
  >({ url: "/items/block_richtext", method: "get", ...variables, signal });

/**
 * List the block_richtext items.
 */
export const useReadItemsBlockRichtext = <
  TData = ReadItemsBlockRichtextResponse
>(
  variables: ReadItemsBlockRichtextVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsBlockRichtextResponse,
      ReadItemsBlockRichtextError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsBlockRichtextResponse,
    ReadItemsBlockRichtextError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_richtext",
      operationId: "readItemsBlockRichtext",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsBlockRichtext({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsBlockRichtextPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsBlockRichtextQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsBlockRichtextError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsBlockRichtextResponse = {
  data?: Schemas.ItemsBlockRichtext;
};

export type ReadSingleItemsBlockRichtextVariables = {
  pathParams: ReadSingleItemsBlockRichtextPathParams;
  queryParams?: ReadSingleItemsBlockRichtextQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single block_richtext item by unique identifier.
 */
export const fetchReadSingleItemsBlockRichtext = (
  variables: ReadSingleItemsBlockRichtextVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsBlockRichtextResponse,
    ReadSingleItemsBlockRichtextError,
    undefined,
    {},
    ReadSingleItemsBlockRichtextQueryParams,
    ReadSingleItemsBlockRichtextPathParams
  >({ url: "/items/block_richtext/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single block_richtext item by unique identifier.
 */
export const useReadSingleItemsBlockRichtext = <
  TData = ReadSingleItemsBlockRichtextResponse
>(
  variables: ReadSingleItemsBlockRichtextVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsBlockRichtextResponse,
      ReadSingleItemsBlockRichtextError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsBlockRichtextResponse,
    ReadSingleItemsBlockRichtextError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/block_richtext/{id}",
      operationId: "readSingleItemsBlockRichtext",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsBlockRichtext(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsCMSCategoryQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsCMSCategoryError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsCMSCategoryResponse = {
  data?: Schemas.ItemsCMSCategory[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsCMSCategoryVariables = {
  queryParams?: ReadItemsCMSCategoryQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the cms_category items.
 */
export const fetchReadItemsCMSCategory = (
  variables: ReadItemsCMSCategoryVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsCMSCategoryResponse,
    ReadItemsCMSCategoryError,
    undefined,
    {},
    ReadItemsCMSCategoryQueryParams,
    {}
  >({ url: "/items/cms_category", method: "get", ...variables, signal });

/**
 * List the cms_category items.
 */
export const useReadItemsCMSCategory = <TData = ReadItemsCMSCategoryResponse>(
  variables: ReadItemsCMSCategoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsCMSCategoryResponse,
      ReadItemsCMSCategoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsCMSCategoryResponse,
    ReadItemsCMSCategoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/cms_category",
      operationId: "readItemsCMSCategory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsCMSCategory({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsCMSCategoryPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsCMSCategoryQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsCMSCategoryError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsCMSCategoryResponse = {
  data?: Schemas.ItemsCMSCategory;
};

export type ReadSingleItemsCMSCategoryVariables = {
  pathParams: ReadSingleItemsCMSCategoryPathParams;
  queryParams?: ReadSingleItemsCMSCategoryQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single cms_category item by unique identifier.
 */
export const fetchReadSingleItemsCMSCategory = (
  variables: ReadSingleItemsCMSCategoryVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsCMSCategoryResponse,
    ReadSingleItemsCMSCategoryError,
    undefined,
    {},
    ReadSingleItemsCMSCategoryQueryParams,
    ReadSingleItemsCMSCategoryPathParams
  >({ url: "/items/cms_category/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single cms_category item by unique identifier.
 */
export const useReadSingleItemsCMSCategory = <
  TData = ReadSingleItemsCMSCategoryResponse
>(
  variables: ReadSingleItemsCMSCategoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsCMSCategoryResponse,
      ReadSingleItemsCMSCategoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsCMSCategoryResponse,
    ReadSingleItemsCMSCategoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/cms_category/{id}",
      operationId: "readSingleItemsCMSCategory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsCMSCategory(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsCMSPageCMSCategoryQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsCMSPageCMSCategoryError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsCMSPageCMSCategoryResponse = {
  data?: Schemas.ItemsCMSPageCMSCategory[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsCMSPageCMSCategoryVariables = {
  queryParams?: ReadItemsCMSPageCMSCategoryQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the cms_page_cms_category items.
 */
export const fetchReadItemsCMSPageCMSCategory = (
  variables: ReadItemsCMSPageCMSCategoryVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsCMSPageCMSCategoryResponse,
    ReadItemsCMSPageCMSCategoryError,
    undefined,
    {},
    ReadItemsCMSPageCMSCategoryQueryParams,
    {}
  >({
    url: "/items/cms_page_cms_category",
    method: "get",
    ...variables,
    signal,
  });

/**
 * List the cms_page_cms_category items.
 */
export const useReadItemsCMSPageCMSCategory = <
  TData = ReadItemsCMSPageCMSCategoryResponse
>(
  variables: ReadItemsCMSPageCMSCategoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsCMSPageCMSCategoryResponse,
      ReadItemsCMSPageCMSCategoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsCMSPageCMSCategoryResponse,
    ReadItemsCMSPageCMSCategoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/cms_page_cms_category",
      operationId: "readItemsCMSPageCMSCategory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsCMSPageCMSCategory(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsCMSPageCMSCategoryPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsCMSPageCMSCategoryQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsCMSPageCMSCategoryError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsCMSPageCMSCategoryResponse = {
  data?: Schemas.ItemsCMSPageCMSCategory;
};

export type ReadSingleItemsCMSPageCMSCategoryVariables = {
  pathParams: ReadSingleItemsCMSPageCMSCategoryPathParams;
  queryParams?: ReadSingleItemsCMSPageCMSCategoryQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single cms_page_cms_category item by unique identifier.
 */
export const fetchReadSingleItemsCMSPageCMSCategory = (
  variables: ReadSingleItemsCMSPageCMSCategoryVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsCMSPageCMSCategoryResponse,
    ReadSingleItemsCMSPageCMSCategoryError,
    undefined,
    {},
    ReadSingleItemsCMSPageCMSCategoryQueryParams,
    ReadSingleItemsCMSPageCMSCategoryPathParams
  >({
    url: "/items/cms_page_cms_category/{id}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Retrieve a single cms_page_cms_category item by unique identifier.
 */
export const useReadSingleItemsCMSPageCMSCategory = <
  TData = ReadSingleItemsCMSPageCMSCategoryResponse
>(
  variables: ReadSingleItemsCMSPageCMSCategoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsCMSPageCMSCategoryResponse,
      ReadSingleItemsCMSPageCMSCategoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsCMSPageCMSCategoryResponse,
    ReadSingleItemsCMSPageCMSCategoryError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/cms_page_cms_category/{id}",
      operationId: "readSingleItemsCMSPageCMSCategory",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsCMSPageCMSCategory(
        { ...fetcherOptions, ...variables },
        signal
      ),
    ...options,
    ...queryOptions,
  });
};

export type ReadItemsCommentsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
};

export type ReadItemsCommentsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.UnauthorizedError;
}>;

export type ReadItemsCommentsResponse = {
  data?: Schemas.ItemsComments[];
  meta?: Schemas.XMetadata;
};

export type ReadItemsCommentsVariables = {
  queryParams?: ReadItemsCommentsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the comments items.
 */
export const fetchReadItemsComments = (
  variables: ReadItemsCommentsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadItemsCommentsResponse,
    ReadItemsCommentsError,
    undefined,
    {},
    ReadItemsCommentsQueryParams,
    {}
  >({ url: "/items/comments", method: "get", ...variables, signal });

/**
 * List the comments items.
 */
export const useReadItemsComments = <TData = ReadItemsCommentsResponse>(
  variables: ReadItemsCommentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadItemsCommentsResponse,
      ReadItemsCommentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadItemsCommentsResponse,
    ReadItemsCommentsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/comments",
      operationId: "readItemsComments",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadItemsComments({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type ReadSingleItemsCommentsPathParams = {
  /**
   * Index of the item.
   */
  id: number | string;
};

export type ReadSingleItemsCommentsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
   */
  version?: string;
};

export type ReadSingleItemsCommentsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type ReadSingleItemsCommentsResponse = {
  data?: Schemas.ItemsComments;
};

export type ReadSingleItemsCommentsVariables = {
  pathParams: ReadSingleItemsCommentsPathParams;
  queryParams?: ReadSingleItemsCommentsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single comments item by unique identifier.
 */
export const fetchReadSingleItemsComments = (
  variables: ReadSingleItemsCommentsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    ReadSingleItemsCommentsResponse,
    ReadSingleItemsCommentsError,
    undefined,
    {},
    ReadSingleItemsCommentsQueryParams,
    ReadSingleItemsCommentsPathParams
  >({ url: "/items/comments/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single comments item by unique identifier.
 */
export const useReadSingleItemsComments = <
  TData = ReadSingleItemsCommentsResponse
>(
  variables: ReadSingleItemsCommentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ReadSingleItemsCommentsResponse,
      ReadSingleItemsCommentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    ReadSingleItemsCommentsResponse,
    ReadSingleItemsCommentsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/items/comments/{id}",
      operationId: "readSingleItemsComments",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadSingleItemsComments({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetFieldsQueryParams = {
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
};

export type GetFieldsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type GetFieldsResponse = {
  data?: Schemas.Fields[];
};

export type GetFieldsVariables = {
  queryParams?: GetFieldsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Returns a list of the fields available in the project.
 */
export const fetchGetFields = (
  variables: GetFieldsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    GetFieldsResponse,
    GetFieldsError,
    undefined,
    {},
    GetFieldsQueryParams,
    {}
  >({ url: "/fields", method: "get", ...variables, signal });

/**
 * Returns a list of the fields available in the project.
 */
export const useGetFields = <TData = GetFieldsResponse>(
  variables: GetFieldsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetFieldsResponse, GetFieldsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<GetFieldsResponse, GetFieldsError, TData>({
    queryKey: queryKeyFn({
      path: "/fields",
      operationId: "getFields",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetFields({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type GetCollectionFieldsPathParams = {
  /**
   * Unique identifier of the collection the item resides in.
   */
  collection: string;
};

export type GetCollectionFieldsQueryParams = {
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
};

export type GetCollectionFieldsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type GetCollectionFieldsResponse = {
  data?: Schemas.Fields[];
};

export type GetCollectionFieldsVariables = {
  pathParams: GetCollectionFieldsPathParams;
  queryParams?: GetCollectionFieldsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Returns a list of the fields available in the given collection.
 */
export const fetchGetCollectionFields = (
  variables: GetCollectionFieldsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    GetCollectionFieldsResponse,
    GetCollectionFieldsError,
    undefined,
    {},
    GetCollectionFieldsQueryParams,
    GetCollectionFieldsPathParams
  >({ url: "/fields/{collection}", method: "get", ...variables, signal });

/**
 * Returns a list of the fields available in the given collection.
 */
export const useGetCollectionFields = <TData = GetCollectionFieldsResponse>(
  variables: GetCollectionFieldsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCollectionFieldsResponse,
      GetCollectionFieldsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    GetCollectionFieldsResponse,
    GetCollectionFieldsError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/fields/{collection}",
      operationId: "getCollectionFields",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCollectionFields({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type CreateFieldPathParams = {
  /**
   * Unique identifier of the collection the item resides in.
   */
  collection: string;
};

export type CreateFieldError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type CreateFieldResponse = {
  data?: Schemas.Fields;
};

export type CreateFieldRequestBody = {
  /**
   * Unique name of the field. Field name is unique within the collection.
   *
   * @example id
   */
  field: string;
  /**
   * Directus specific data type. Used to cast values in the API.
   *
   * @example integer
   */
  type: string;
  /**
   * The schema info.
   */
  schema?: {
    /**
     * The name of the field.
     *
     * @example title
     */
    name?: string;
    /**
     * The collection of the field.
     *
     * @example posts
     */
    table?: string;
    /**
     * The type of the field.
     *
     * @example string
     */
    type?: string;
    /**
     * The default value of the field.
     *
     * @example null
     */
    default_value?: string | null;
    /**
     * The max length of the field.
     *
     * @example null
     */
    max_length?: number | null;
    /**
     * If the field is nullable.
     *
     * @example false
     */
    is_nullable?: boolean;
    /**
     * If the field is primary key.
     *
     * @example false
     */
    is_primary_key?: boolean;
    /**
     * If the field has auto increment.
     *
     * @example false
     */
    has_auto_increment?: boolean;
    /**
     * Related column from the foreign key constraint.
     *
     * @example null
     */
    foreign_key_column?: string | null;
    /**
     * Related table from the foreign key constraint.
     *
     * @example null
     */
    foreign_key_table?: string | null;
    /**
     * Comment as saved in the database.
     *
     * @example null
     */
    comment?: string | null;
    /**
     * Database schema (pg only).
     *
     * @example public
     */
    schema?: string;
    /**
     * Related schema from the foreign key constraint (pg only).
     *
     * @example null
     */
    foreign_key_schema?: string | null;
  };
  /**
   * The meta info.
   */
  meta?: {
    /**
     * Unique identifier for the field in the `directus_fields` collection.
     *
     * @example 3
     */
    id?: number;
    /**
     * Unique name of the collection this field is in.
     *
     * @example posts
     */
    collection?: string;
    /**
     * Unique name of the field. Field name is unique within the collection.
     *
     * @example title
     */
    field?: string;
    /**
     * Transformation flag for field
     *
     * @example null
     */
    special?: string[] | null;
    /**
     * What interface is used in the admin app to edit the value for this field.
     *
     * @example primary-key
     */
    ["system-interface"]?: string | null;
    /**
     * Options for the interface that's used. This format is based on the individual interface.
     *
     * @example null
     */
    options?: Record<string, any> | null;
    /**
     * What display is used in the admin app to display the value for this field.
     *
     * @example null
     */
    display?: string | null;
    /**
     * Options for the display that's used. This format is based on the individual display.
     *
     * @example null
     */
    display_options?: Record<string, any> | null;
    /**
     * If the field can be altered by the end user. Directus system fields have this value set to `true`.
     *
     * @example true
     */
    locked?: boolean;
    /**
     * Prevents the user from editing the value in the field.
     *
     * @example false
     */
    readonly?: boolean;
    /**
     * If this field should be hidden.
     *
     * @example true
     */
    hidden?: boolean;
    /**
     * Sort order of this field on the edit page of the admin app.
     *
     * @example 1
     */
    sort?: number | null;
    /**
     * Width of the field on the edit form.
     *
     * @example null
     */
    width?: "half" | "half-left" | "half-right" | "full" | "fill" | any | null;
    /**
     * What field group this field is part of.
     *
     * @example null
     */
    group?: number | null;
    /**
     * Key value pair of `<language>: <translation>` that allows the user to change the displayed name of the field in the admin app.
     *
     * @example null
     */
    translation?: Record<string, any> | null;
    /**
     * A user provided note for the field. Will be rendered alongside the interface on the edit page.
     *
     * @example
     */
    note?: string | null;
  } | null;
};

export type CreateFieldVariables = {
  body: CreateFieldRequestBody;
  pathParams: CreateFieldPathParams;
} & BackendContext["fetcherOptions"];

/**
 * Create a new field in a given collection.
 */
export const fetchCreateField = (
  variables: CreateFieldVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    CreateFieldResponse,
    CreateFieldError,
    CreateFieldRequestBody,
    {},
    {},
    CreateFieldPathParams
  >({ url: "/fields/{collection}", method: "post", ...variables, signal });

/**
 * Create a new field in a given collection.
 */
export const useCreateField = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      CreateFieldResponse,
      CreateFieldError,
      CreateFieldVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<
    CreateFieldResponse,
    CreateFieldError,
    CreateFieldVariables
  >({
    mutationFn: (variables: CreateFieldVariables) =>
      fetchCreateField({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetCollectionFieldPathParams = {
  /**
   * Unique identifier of the collection the item resides in.
   */
  collection: string;
  /**
   * Unique identifier of the field.
   */
  id: string;
};

export type GetCollectionFieldError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type GetCollectionFieldResponse = {
  data?: Schemas.Fields;
};

export type GetCollectionFieldVariables = {
  pathParams: GetCollectionFieldPathParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieves the details of a single field in a given collection.
 */
export const fetchGetCollectionField = (
  variables: GetCollectionFieldVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    GetCollectionFieldResponse,
    GetCollectionFieldError,
    undefined,
    {},
    {},
    GetCollectionFieldPathParams
  >({ url: "/fields/{collection}/{id}", method: "get", ...variables, signal });

/**
 * Retrieves the details of a single field in a given collection.
 */
export const useGetCollectionField = <TData = GetCollectionFieldResponse>(
  variables: GetCollectionFieldVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCollectionFieldResponse,
      GetCollectionFieldError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<
    GetCollectionFieldResponse,
    GetCollectionFieldError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/fields/{collection}/{id}",
      operationId: "getCollectionField",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetCollectionField({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UpdateFieldPathParams = {
  /**
   * Unique identifier of the collection the item resides in.
   */
  collection: string;
  /**
   * Unique identifier of the field.
   */
  id: string;
};

export type UpdateFieldError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type UpdateFieldResponse = {
  data?: Schemas.Fields;
};

export type UpdateFieldRequestBody = {
  /**
   * Unique name of the field. Field name is unique within the collection.
   *
   * @example id
   */
  field?: string;
  /**
   * Directus specific data type. Used to cast values in the API.
   *
   * @example integer
   */
  type?: string;
  /**
   * The schema info.
   */
  schema?: {
    /**
     * The name of the field.
     *
     * @example title
     */
    name?: string;
    /**
     * The collection of the field.
     *
     * @example posts
     */
    table?: string;
    /**
     * The type of the field.
     *
     * @example string
     */
    type?: string;
    /**
     * The default value of the field.
     *
     * @example null
     */
    default_value?: string | null;
    /**
     * The max length of the field.
     *
     * @example null
     */
    max_length?: number | null;
    /**
     * If the field is nullable.
     *
     * @example false
     */
    is_nullable?: boolean;
    /**
     * If the field is primary key.
     *
     * @example false
     */
    is_primary_key?: boolean;
    /**
     * If the field has auto increment.
     *
     * @example false
     */
    has_auto_increment?: boolean;
    /**
     * Related column from the foreign key constraint.
     *
     * @example null
     */
    foreign_key_column?: string | null;
    /**
     * Related table from the foreign key constraint.
     *
     * @example null
     */
    foreign_key_table?: string | null;
    /**
     * Comment as saved in the database.
     *
     * @example null
     */
    comment?: string | null;
    /**
     * Database schema (pg only).
     *
     * @example public
     */
    schema?: string;
    /**
     * Related schema from the foreign key constraint (pg only).
     *
     * @example null
     */
    foreign_key_schema?: string | null;
  };
  /**
   * The meta info.
   */
  meta?: {
    /**
     * Unique identifier for the field in the `directus_fields` collection.
     *
     * @example 3
     */
    id?: number;
    /**
     * Unique name of the collection this field is in.
     *
     * @example posts
     */
    collection?: string;
    /**
     * Unique name of the field. Field name is unique within the collection.
     *
     * @example title
     */
    field?: string;
    /**
     * Transformation flag for field
     *
     * @example null
     */
    special?: string[] | null;
    /**
     * What interface is used in the admin app to edit the value for this field.
     *
     * @example primary-key
     */
    ["system-interface"]?: string | null;
    /**
     * Options for the interface that's used. This format is based on the individual interface.
     *
     * @example null
     */
    options?: Record<string, any> | null;
    /**
     * What display is used in the admin app to display the value for this field.
     *
     * @example null
     */
    display?: string | null;
    /**
     * Options for the display that's used. This format is based on the individual display.
     *
     * @example null
     */
    display_options?: Record<string, any> | null;
    /**
     * If the field can be altered by the end user. Directus system fields have this value set to `true`.
     *
     * @example true
     */
    locked?: boolean;
    /**
     * Prevents the user from editing the value in the field.
     *
     * @example false
     */
    readonly?: boolean;
    /**
     * If this field should be hidden.
     *
     * @example true
     */
    hidden?: boolean;
    /**
     * Sort order of this field on the edit page of the admin app.
     *
     * @example 1
     */
    sort?: number | null;
    /**
     * Width of the field on the edit form.
     *
     * @example null
     */
    width?: "half" | "half-left" | "half-right" | "full" | "fill" | any | null;
    /**
     * What field group this field is part of.
     *
     * @example null
     */
    group?: number | null;
    /**
     * Key value pair of `<language>: <translation>` that allows the user to change the displayed name of the field in the admin app.
     *
     * @example null
     */
    translation?: Record<string, any> | null;
    /**
     * A user provided note for the field. Will be rendered alongside the interface on the edit page.
     *
     * @example
     */
    note?: string | null;
  } | null;
};

export type UpdateFieldVariables = {
  body?: UpdateFieldRequestBody;
  pathParams: UpdateFieldPathParams;
} & BackendContext["fetcherOptions"];

/**
 * Update an existing field.
 */
export const fetchUpdateField = (
  variables: UpdateFieldVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    UpdateFieldResponse,
    UpdateFieldError,
    UpdateFieldRequestBody,
    {},
    {},
    UpdateFieldPathParams
  >({
    url: "/fields/{collection}/{id}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update an existing field.
 */
export const useUpdateField = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UpdateFieldResponse,
      UpdateFieldError,
      UpdateFieldVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<
    UpdateFieldResponse,
    UpdateFieldError,
    UpdateFieldVariables
  >({
    mutationFn: (variables: UpdateFieldVariables) =>
      fetchUpdateField({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteFieldPathParams = {
  /**
   * Unique identifier of the collection the item resides in.
   */
  collection: string;
  /**
   * Unique identifier of the field.
   */
  id: string;
};

export type DeleteFieldError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type DeleteFieldVariables = {
  pathParams: DeleteFieldPathParams;
} & BackendContext["fetcherOptions"];

/**
 * Delete an existing field.
 */
export const fetchDeleteField = (
  variables: DeleteFieldVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    undefined,
    DeleteFieldError,
    undefined,
    {},
    {},
    DeleteFieldPathParams
  >({
    url: "/fields/{collection}/{id}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete an existing field.
 */
export const useDeleteField = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteFieldError,
      DeleteFieldVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<
    undefined,
    DeleteFieldError,
    DeleteFieldVariables
  >({
    mutationFn: (variables: DeleteFieldVariables) =>
      fetchDeleteField({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetRelationsQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * A limit on the number of objects that are returned.
   */
  limit?: number;
  /**
   * How many items to skip when fetching data.
   */
  offset?: number;
  /**
   * What metadata to return in the response.
   */
  meta?: string;
  /**
   * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
   */
  sort?: string[];
  /**
   * Select items in collection by given conditions.
   */
  filter?: string[];
  /**
   * Filter by items that contain the given search query in one of their fields.
   */
  search?: string;
  /**
   * Cursor for use in pagination. Often used in combination with limit.
   */
  page?: number;
};

export type GetRelationsError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type GetRelationsResponse = {
  data?: Schemas.Relations[];
};

export type GetRelationsVariables = {
  queryParams?: GetRelationsQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * List the relations.
 */
export const fetchGetRelations = (
  variables: GetRelationsVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    GetRelationsResponse,
    GetRelationsError,
    undefined,
    {},
    GetRelationsQueryParams,
    {}
  >({ url: "/relations", method: "get", ...variables, signal });

/**
 * List the relations.
 */
export const useGetRelations = <TData = GetRelationsResponse>(
  variables: GetRelationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetRelationsResponse, GetRelationsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<GetRelationsResponse, GetRelationsError, TData>({
    queryKey: queryKeyFn({
      path: "/relations",
      operationId: "getRelations",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetRelations({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type CreateRelationQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
};

export type CreateRelationError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type CreateRelationResponse = {
  data?: Schemas.Relations;
};

export type CreateRelationRequestBody = {
  /**
   * Collection that has the field that holds the foreign key.
   *
   * @example articles
   */
  collection_many?: string;
  /**
   * Collection on the _one_ side of the relationship.
   *
   * @example authors
   */
  collection_one?: string;
  /**
   * Foreign key. Field that holds the primary key of the related collection.
   *
   * @example author
   */
  field_many?: string;
  /**
   * Alias column that serves as the _one_ side of the relationship.
   *
   * @example books
   */
  field_one?: string;
  /**
   * Field on the junction table that holds the primary key of the related collection.
   */
  junction_field?: string;
};

export type CreateRelationVariables = {
  body?: CreateRelationRequestBody;
  queryParams?: CreateRelationQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Create a new relation.
 */
export const fetchCreateRelation = (
  variables: CreateRelationVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    CreateRelationResponse,
    CreateRelationError,
    CreateRelationRequestBody,
    {},
    CreateRelationQueryParams,
    {}
  >({ url: "/relations", method: "post", ...variables, signal });

/**
 * Create a new relation.
 */
export const useCreateRelation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      CreateRelationResponse,
      CreateRelationError,
      CreateRelationVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<
    CreateRelationResponse,
    CreateRelationError,
    CreateRelationVariables
  >({
    mutationFn: (variables: CreateRelationVariables) =>
      fetchCreateRelation({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetRelationPathParams = {
  /**
   * Index
   */
  id: number;
};

export type GetRelationQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
};

export type GetRelationError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type GetRelationResponse = {
  data?: Schemas.Relations;
};

export type GetRelationVariables = {
  pathParams: GetRelationPathParams;
  queryParams?: GetRelationQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Retrieve a single relation by unique identifier.
 */
export const fetchGetRelation = (
  variables: GetRelationVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    GetRelationResponse,
    GetRelationError,
    undefined,
    {},
    GetRelationQueryParams,
    GetRelationPathParams
  >({ url: "/relations/{id}", method: "get", ...variables, signal });

/**
 * Retrieve a single relation by unique identifier.
 */
export const useGetRelation = <TData = GetRelationResponse>(
  variables: GetRelationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetRelationResponse, GetRelationError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useBackendContext(options);
  return reactQuery.useQuery<GetRelationResponse, GetRelationError, TData>({
    queryKey: queryKeyFn({
      path: "/relations/{id}",
      operationId: "getRelation",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetRelation({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type UpdateRelationPathParams = {
  /**
   * Index
   */
  id: number;
};

export type UpdateRelationQueryParams = {
  /**
   * Control what fields are being returned in the object.
   */
  fields?: string[];
  /**
   * What metadata to return in the response.
   */
  meta?: string;
};

export type UpdateRelationError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type UpdateRelationResponse = {
  data?: Schemas.Relations;
};

export type UpdateRelationRequestBody = {
  /**
   * Collection that has the field that holds the foreign key.
   */
  collection_many?: string;
  /**
   * Collection on the _one_ side of the relationship.
   */
  collection_one?: string;
  /**
   * Foreign key. Field that holds the primary key of the related collection.
   */
  field_many?: string;
  /**
   * Alias column that serves as the _one_ side of the relationship.
   *
   * @example books
   */
  field_one?: string;
  /**
   * Field on the junction table that holds the primary key of the related collection.
   */
  junction_field?: string;
};

export type UpdateRelationVariables = {
  body?: UpdateRelationRequestBody;
  pathParams: UpdateRelationPathParams;
  queryParams?: UpdateRelationQueryParams;
} & BackendContext["fetcherOptions"];

/**
 * Update an existing relation
 */
export const fetchUpdateRelation = (
  variables: UpdateRelationVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    UpdateRelationResponse,
    UpdateRelationError,
    UpdateRelationRequestBody,
    {},
    UpdateRelationQueryParams,
    UpdateRelationPathParams
  >({ url: "/relations/{id}", method: "patch", ...variables, signal });

/**
 * Update an existing relation
 */
export const useUpdateRelation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      UpdateRelationResponse,
      UpdateRelationError,
      UpdateRelationVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<
    UpdateRelationResponse,
    UpdateRelationError,
    UpdateRelationVariables
  >({
    mutationFn: (variables: UpdateRelationVariables) =>
      fetchUpdateRelation({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteRelationPathParams = {
  /**
   * Index
   */
  id: number;
};

export type DeleteRelationError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.UnauthorizedError;
    }
  | {
      status: 404;
      payload: Responses.NotFoundError;
    }
>;

export type DeleteRelationVariables = {
  pathParams: DeleteRelationPathParams;
} & BackendContext["fetcherOptions"];

/**
 * Delete an existing relation.
 */
export const fetchDeleteRelation = (
  variables: DeleteRelationVariables,
  signal?: AbortSignal
) =>
  backendFetch<
    undefined,
    DeleteRelationError,
    undefined,
    {},
    {},
    DeleteRelationPathParams
  >({ url: "/relations/{id}", method: "delete", ...variables, signal });

/**
 * Delete an existing relation.
 */
export const useDeleteRelation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteRelationError,
      DeleteRelationVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useBackendContext();
  return reactQuery.useMutation<
    undefined,
    DeleteRelationError,
    DeleteRelationVariables
  >({
    mutationFn: (variables: DeleteRelationVariables) =>
      fetchDeleteRelation({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/assets/{id}";
      operationId: "getAsset";
      variables: GetAssetVariables;
    }
  | {
      path: "/auth/oauth";
      operationId: "oauth";
      variables: OauthVariables;
    }
  | {
      path: "/auth/oauth/{provider}";
      operationId: "oauthProvider";
      variables: OauthProviderVariables;
    }
  | {
      path: "/server/info";
      operationId: "serverInfo";
      variables: ServerInfoVariables;
    }
  | {
      path: "/server/ping";
      operationId: "ping";
      variables: PingVariables;
    }
  | {
      path: "/items/escalation_pathways";
      operationId: "readItemsEscalationPathways";
      variables: ReadItemsEscalationPathwaysVariables;
    }
  | {
      path: "/items/escalation_pathways/{id}";
      operationId: "readSingleItemsEscalationPathways";
      variables: ReadSingleItemsEscalationPathwaysVariables;
    }
  | {
      path: "/items/escalation_pathway_statuses";
      operationId: "readItemsEscalationPathwayStatuses";
      variables: ReadItemsEscalationPathwayStatusesVariables;
    }
  | {
      path: "/items/escalation_pathway_statuses/{id}";
      operationId: "readSingleItemsEscalationPathwayStatuses";
      variables: ReadSingleItemsEscalationPathwayStatusesVariables;
    }
  | {
      path: "/items/escalation_regions";
      operationId: "readItemsEscalationRegions";
      variables: ReadItemsEscalationRegionsVariables;
    }
  | {
      path: "/items/escalation_regions/{id}";
      operationId: "readSingleItemsEscalationRegions";
      variables: ReadSingleItemsEscalationRegionsVariables;
    }
  | {
      path: "/items/global";
      operationId: "readItemsGlobal";
      variables: ReadItemsGlobalVariables;
    }
  | {
      path: "/items/global/{id}";
      operationId: "readSingleItemsGlobal";
      variables: ReadSingleItemsGlobalVariables;
    }
  | {
      path: "/items/homepage";
      operationId: "readItemsHomepage";
      variables: ReadItemsHomepageVariables;
    }
  | {
      path: "/items/homepage/{id}";
      operationId: "readSingleItemsHomepage";
      variables: ReadSingleItemsHomepageVariables;
    }
  | {
      path: "/items/navigations";
      operationId: "readItemsNavigations";
      variables: ReadItemsNavigationsVariables;
    }
  | {
      path: "/items/navigations/{id}";
      operationId: "readSingleItemsNavigations";
      variables: ReadSingleItemsNavigationsVariables;
    }
  | {
      path: "/items/sanction_entities";
      operationId: "readItemsSanctionEntities";
      variables: ReadItemsSanctionEntitiesVariables;
    }
  | {
      path: "/items/sanction_entities/{id}";
      operationId: "readSingleItemsSanctionEntities";
      variables: ReadSingleItemsSanctionEntitiesVariables;
    }
  | {
      path: "/items/sanction_sectors";
      operationId: "readItemsSanctionSectors";
      variables: ReadItemsSanctionSectorsVariables;
    }
  | {
      path: "/items/sanction_sectors/{id}";
      operationId: "readSingleItemsSanctionSectors";
      variables: ReadSingleItemsSanctionSectorsVariables;
    }
  | {
      path: "/items/sanction_types";
      operationId: "readItemsSanctionTypes";
      variables: ReadItemsSanctionTypesVariables;
    }
  | {
      path: "/items/sanction_types/{id}";
      operationId: "readSingleItemsSanctionTypes";
      variables: ReadSingleItemsSanctionTypesVariables;
    }
  | {
      path: "/items/sanctions";
      operationId: "readItemsSanctions";
      variables: ReadItemsSanctionsVariables;
    }
  | {
      path: "/items/sanctions/{id}";
      operationId: "readSingleItemsSanctions";
      variables: ReadSingleItemsSanctionsVariables;
    }
  | {
      path: "/items/sanctions_sanction_purposes";
      operationId: "readItemsSanctionsSanctionPurposes";
      variables: ReadItemsSanctionsSanctionPurposesVariables;
    }
  | {
      path: "/items/sanctions_sanction_purposes/{id}";
      operationId: "readSingleItemsSanctionsSanctionPurposes";
      variables: ReadSingleItemsSanctionsSanctionPurposesVariables;
    }
  | {
      path: "/items/wiki_page";
      operationId: "readItemsWikiPage";
      variables: ReadItemsWikiPageVariables;
    }
  | {
      path: "/items/wiki_page/{id}";
      operationId: "readSingleItemsWikiPage";
      variables: ReadSingleItemsWikiPageVariables;
    }
  | {
      path: "/items/wiki_page_wiki_category";
      operationId: "readItemsWikiPageWikiCategory";
      variables: ReadItemsWikiPageWikiCategoryVariables;
    }
  | {
      path: "/items/wiki_page_wiki_category/{id}";
      operationId: "readSingleItemsWikiPageWikiCategory";
      variables: ReadSingleItemsWikiPageWikiCategoryVariables;
    }
  | {
      path: "/items/sanctions_sanction_types";
      operationId: "readItemsSanctionsSanctionTypes";
      variables: ReadItemsSanctionsSanctionTypesVariables;
    }
  | {
      path: "/items/sanctions_sanction_types/{id}";
      operationId: "readSingleItemsSanctionsSanctionTypes";
      variables: ReadSingleItemsSanctionsSanctionTypesVariables;
    }
  | {
      path: "/items/wiki_category";
      operationId: "readItemsWikiCategory";
      variables: ReadItemsWikiCategoryVariables;
    }
  | {
      path: "/items/wiki_category/{id}";
      operationId: "readSingleItemsWikiCategory";
      variables: ReadSingleItemsWikiCategoryVariables;
    }
  | {
      path: "/items/article_sources_articles";
      operationId: "readItemsArticleSourcesArticles";
      variables: ReadItemsArticleSourcesArticlesVariables;
    }
  | {
      path: "/items/article_sources_articles/{id}";
      operationId: "readSingleItemsArticleSourcesArticles";
      variables: ReadSingleItemsArticleSourcesArticlesVariables;
    }
  | {
      path: "/items/homepage_blocks";
      operationId: "readItemsHomepageBlocks";
      variables: ReadItemsHomepageBlocksVariables;
    }
  | {
      path: "/items/homepage_blocks/{id}";
      operationId: "readSingleItemsHomepageBlocks";
      variables: ReadSingleItemsHomepageBlocksVariables;
    }
  | {
      path: "/items/sanction_purposes";
      operationId: "readItemsSanctionPurposes";
      variables: ReadItemsSanctionPurposesVariables;
    }
  | {
      path: "/items/sanction_purposes/{id}";
      operationId: "readSingleItemsSanctionPurposes";
      variables: ReadSingleItemsSanctionPurposesVariables;
    }
  | {
      path: "/items/sanctions_sanction_sectors";
      operationId: "readItemsSanctionsSanctionSectors";
      variables: ReadItemsSanctionsSanctionSectorsVariables;
    }
  | {
      path: "/items/sanctions_sanction_sectors/{id}";
      operationId: "readSingleItemsSanctionsSanctionSectors";
      variables: ReadSingleItemsSanctionsSanctionSectorsVariables;
    }
  | {
      path: "/files";
      operationId: "getFiles";
      variables: GetFilesVariables;
    }
  | {
      path: "/files/{id}";
      operationId: "getFile";
      variables: GetFileVariables;
    }
  | {
      path: "/items/article_sources";
      operationId: "readItemsArticleSources";
      variables: ReadItemsArticleSourcesVariables;
    }
  | {
      path: "/items/article_sources/{id}";
      operationId: "readSingleItemsArticleSources";
      variables: ReadSingleItemsArticleSourcesVariables;
    }
  | {
      path: "/items/articles";
      operationId: "readItemsArticles";
      variables: ReadItemsArticlesVariables;
    }
  | {
      path: "/items/articles/{id}";
      operationId: "readSingleItemsArticles";
      variables: ReadSingleItemsArticlesVariables;
    }
  | {
      path: "/items/articles_directus_users";
      operationId: "readItemsArticlesDirectusUsers";
      variables: ReadItemsArticlesDirectusUsersVariables;
    }
  | {
      path: "/items/articles_directus_users/{id}";
      operationId: "readSingleItemsArticlesDirectusUsers";
      variables: ReadSingleItemsArticlesDirectusUsersVariables;
    }
  | {
      path: "/items/articles_escalation_pathways";
      operationId: "readItemsArticlesEscalationPathways";
      variables: ReadItemsArticlesEscalationPathwaysVariables;
    }
  | {
      path: "/items/articles_escalation_pathways/{id}";
      operationId: "readSingleItemsArticlesEscalationPathways";
      variables: ReadSingleItemsArticlesEscalationPathwaysVariables;
    }
  | {
      path: "/items/block_cardgroup";
      operationId: "readItemsBlockCardgroup";
      variables: ReadItemsBlockCardgroupVariables;
    }
  | {
      path: "/items/block_cardgroup/{id}";
      operationId: "readSingleItemsBlockCardgroup";
      variables: ReadSingleItemsBlockCardgroupVariables;
    }
  | {
      path: "/items/block_cardgroup_cards";
      operationId: "readItemsBlockCardgroupCards";
      variables: ReadItemsBlockCardgroupCardsVariables;
    }
  | {
      path: "/items/block_cardgroup_cards/{id}";
      operationId: "readSingleItemsBlockCardgroupCards";
      variables: ReadSingleItemsBlockCardgroupCardsVariables;
    }
  | {
      path: "/items/block_cardgroup_cms_page";
      operationId: "readItemsBlockCardgroupCMSPage";
      variables: ReadItemsBlockCardgroupCMSPageVariables;
    }
  | {
      path: "/items/block_cardgroup_cms_page/{id}";
      operationId: "readSingleItemsBlockCardgroupCMSPage";
      variables: ReadSingleItemsBlockCardgroupCMSPageVariables;
    }
  | {
      path: "/items/block_hero";
      operationId: "readItemsBlockHero";
      variables: ReadItemsBlockHeroVariables;
    }
  | {
      path: "/items/block_hero/{id}";
      operationId: "readSingleItemsBlockHero";
      variables: ReadSingleItemsBlockHeroVariables;
    }
  | {
      path: "/items/cms_page";
      operationId: "readItemsCMSPage";
      variables: ReadItemsCMSPageVariables;
    }
  | {
      path: "/items/cms_page/{id}";
      operationId: "readSingleItemsCMSPage";
      variables: ReadSingleItemsCMSPageVariables;
    }
  | {
      path: "/items/block_richtext";
      operationId: "readItemsBlockRichtext";
      variables: ReadItemsBlockRichtextVariables;
    }
  | {
      path: "/items/block_richtext/{id}";
      operationId: "readSingleItemsBlockRichtext";
      variables: ReadSingleItemsBlockRichtextVariables;
    }
  | {
      path: "/items/cms_category";
      operationId: "readItemsCMSCategory";
      variables: ReadItemsCMSCategoryVariables;
    }
  | {
      path: "/items/cms_category/{id}";
      operationId: "readSingleItemsCMSCategory";
      variables: ReadSingleItemsCMSCategoryVariables;
    }
  | {
      path: "/items/cms_page_cms_category";
      operationId: "readItemsCMSPageCMSCategory";
      variables: ReadItemsCMSPageCMSCategoryVariables;
    }
  | {
      path: "/items/cms_page_cms_category/{id}";
      operationId: "readSingleItemsCMSPageCMSCategory";
      variables: ReadSingleItemsCMSPageCMSCategoryVariables;
    }
  | {
      path: "/items/comments";
      operationId: "readItemsComments";
      variables: ReadItemsCommentsVariables;
    }
  | {
      path: "/items/comments/{id}";
      operationId: "readSingleItemsComments";
      variables: ReadSingleItemsCommentsVariables;
    }
  | {
      path: "/fields";
      operationId: "getFields";
      variables: GetFieldsVariables;
    }
  | {
      path: "/fields/{collection}";
      operationId: "getCollectionFields";
      variables: GetCollectionFieldsVariables;
    }
  | {
      path: "/fields/{collection}/{id}";
      operationId: "getCollectionField";
      variables: GetCollectionFieldVariables;
    }
  | {
      path: "/relations";
      operationId: "getRelations";
      variables: GetRelationsVariables;
    }
  | {
      path: "/relations/{id}";
      operationId: "getRelation";
      variables: GetRelationVariables;
    };
